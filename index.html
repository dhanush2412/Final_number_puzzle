<!DOCTYPE html>
<html lang="en">
    <script>
        !function (t, e) { var o, n, p, r; e.__SV || (window.posthog = e, e._i = [], e.init = function (i, s, a) { function g(t, e) { var o = e.split("."); 2 == o.length && (t = t[o[0]], e = o[1]), t[e] = function () { t.push([e].concat(Array.prototype.slice.call(arguments, 0))) } } (p = t.createElement("script")).type = "text/javascript", p.crossOrigin = "anonymous", p.async = !0, p.src = s.api_host.replace(".i.posthog.com", "-assets.i.posthog.com") + "/static/array.js", (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(p, r); var u = e; for (void 0 !== a ? u = e[a] = [] : a = "posthog", u.people = u.people || [], u.toString = function (t) { var e = "posthog"; return "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e }, u.people.toString = function () { return u.toString(1) + ".people (stub)" }, o = "init Re Ms Fs Pe Rs Cs capture Ve calculateEventProperties Ds register register_once register_for_session unregister unregister_for_session zs getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty Ls As createPersonProfile Ns Is Us opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing is_capturing clear_opt_in_out_capturing Os debug I js getPageViewId captureTraceFeedback captureTraceMetric".split(" "), n = 0; n < o.length; n++)g(u, o[n]); e._i.push([i, s, a]) }, e.__SV = 1) }(document, window.posthog || []);
        posthog.init('phc_BLLJRB5R4OuRU4u72Sagt5LE99ueBMZ1DmrHH8uksJs', {
            api_host: 'https://us.i.posthog.com',
            person_profiles: 'identified_only',
        })
    </script>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Match - Deterministic Engine</title>
    <!-- Google Analytics (GA4) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VJ8QX92N8H"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-QLP10NJJMC');
    </script>
    <!-- Meta Pixel Code -->
    <script>
        !function (f, b, e, v, n, t, s) {
            if (f.fbq) return; n = f.fbq = function () {
                n.callMethod ? n.callMethod.apply(n, arguments) : n.queue.push(arguments);
            };
            if (!f._fbq) f._fbq = n;
            n.push = n;
            n.loaded = true;
            n.version = '2.0';
            n.queue = [];
            t = b.createElement(e);
            t.async = true;
            t.src = v;
            s = b.getElementsByTagName(e)[0];
            s.parentNode.insertBefore(t, s);
        }(window, document, 'script', 'https://connect.facebook.net/en_US/fbevents.js');
        fbq('init', 'YOUR_META_PIXEL_ID');
        fbq('track', 'PageView');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #E3ECF7;
            color: #2C3E50;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            padding: 10px 12px;
        }

        .top-header {
            width: 100%;
            max-width: 420px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 2px 0 10px;
        }

        .home-btn {
            width: 46px;
            height: 46px;
            border: none;
            background: none;
            font-size: 1.8rem;
            cursor: pointer;
            padding: 0;
            box-shadow: none;
        }

        h1 {
            font-size: 2.0rem;
            font-weight: 800;
            color: #2B4867;
            letter-spacing: .2px;
            margin: 0
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .icon-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            font-size: 1.5rem;
            font-weight: 800;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: none;
            padding: 0;
        }

        #btn-restart.icon-btn {
            background: #d2d1cf;
            color: #4f5b66;
        }

        #btn-hint.icon-btn {
            background: #f2cc2f;
            color: #fff;
        }

        #hud {
            width: 100%;
            max-width: 420px;
            display: flex;
            gap: 14px;
            margin: 0 0 10px;
            justify-content: center
        }

        .stat-card {
            flex: 1;
            background: #B9C9D8;
            border: 3px solid #A5BBD0;
            border-radius: 18px;
            padding: 10px 8px 12px;
            text-align: center;
            min-height: 92px;
        }

        .stat-label {
            font-size: 2rem;
            line-height: 1;
            margin-bottom: 4px;
        }

        .stat-title {
            display: block;
            font-size: 2rem;
            color: #4f6b86;
            margin-bottom: 4px;
        }

        .stat-value {
            display: block;
            color: #2B4867;
            font-size: 2.6rem;
            font-weight: 800;
            line-height: 1;
        }

        #meta-hidden {
            display: none;
        }


        #info-box {
            width: 100%;
            max-width: 420px;
            min-height: 0;
            margin: 0 0 8px;
            font-size: .86rem;
            color: #5D6E82;
            text-align: center;
        }

        #hud {
            width: 100%;
            max-width: 420px;
            display: flex;
            gap: 10px;
            margin: 0 0 10px;
            justify-content: center;
            align-items: center;
            font-size: .9rem;
            color: #4E6075;
            flex-wrap: wrap;
        }

        #hud span b {
            color: #2B4867;
        }

        #board-wrap {
            width: 100%;
            max-width: 420px;
            position: relative;
            overflow-y: auto;
            max-height: 62vh;
            border: 2px solid #C0CFDF;
            border-radius: 8px;
            background: #F0F4FA;
            padding: 0
        }

        #board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.05rem, 4.2vw, 1.5rem);
            font-weight: 700;
            cursor: pointer;
            border: .5px solid #D0DAE6;
            background: #fff;
            color: #2C3E50;
            transition: background .12s, border-color .12s, box-shadow .12s;
            user-select: none
        }

        .cell.num {
            background: #fff;
            color: #B3BCC8;
            border: .5px solid #D0DAE6
        }

        .cell.num:hover {
            background: #EEF4FB;
            border-color: #9FC2E8
        }

        .cell.empty {
            background: #fff;
            color: transparent;
            cursor: default;
            border: .5px solid #E4EAF2
        }

        .cell.selected {
            background: #BBDEFB;
            border-color: #42A5F5;
            box-shadow: 0 0 0 1px #42A5F5 inset;
            z-index: 1
        }

        .cell.matched {
            animation: pop .3s ease-out forwards
        }

        .cell.invalid {
            animation: shake .25s ease-out
        }

        .cell.hint-glow {
            animation: pulse .6s ease-in-out 2
        }

        @keyframes pop {
            0% {
                transform: scale(1);
                opacity: 1
            }

            50% {
                transform: scale(1.15);
                opacity: .5
            }

            100% {
                transform: scale(.85);
                opacity: 0
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0)
            }

            25% {
                transform: translateX(-4px)
            }

            75% {
                transform: translateX(4px)
            }
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 4px rgba(255, 170, 0, .2)
            }

            50% {
                box-shadow: 0 0 14px rgba(255, 170, 0, .7);
                border-color: #FFA000
            }
        }

        #controls {
            width: 100%;
            max-width: 420px;
            display: flex;
            gap: 8px;
            margin-top: 12px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center
        }

        button {
            padding: 10px 14px;
            border: 1px solid #B8CBE0;
            border-radius: 10px;
            background: #D6E4F0;
            color: #2C3E50;
            font-size: .82rem;
            font-weight: 700;
            cursor: pointer;
            transition: background .2s, transform .15s, box-shadow .15s
        }

        button:hover:not(:disabled) {
            background: #C9DCF0;
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, .08)
        }

        button:disabled {
            opacity: .45;
            cursor: not-allowed
        }

        button.shuffle-btn {
            background: linear-gradient(145deg, #5B9BD5, #3A7BD5);
            border-color: #3A7BD5;
            color: #fff
        }

        button.shuffle-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #6AA8DF, #4A89DD)
        }

        button.shuffle-btn::before {
            content: '';
            margin-right: 0
        }

        label[for="level-select"] {
            font-size: .82rem;
            color: #5A6B7C;
            font-weight: 700
        }

        select {
            padding: 10px 12px;
            border: 1px solid #B8CBE0;
            border-radius: 10px;
            background: #fff;
            color: #2C3E50;
            font-size: .82rem;
            font-weight: 700;
        }

        #msg {
            width: 100%;
            max-width: 420px;
            margin-top: 8px;
            font-size: .78rem;
            min-height: 1.3em;
            color: #6B7C93;
            text-align: center
        }

        #level-complete {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(30, 46, 70, .45);
            z-index: 10;
            flex-direction: column;
            align-items: center;
            justify-content: center
        }

        #level-complete.show {
            display: flex
        }

        #level-complete div {
            background: #F7FAFF;
            padding: 26px 30px;
            border-radius: 14px;
            text-align: center;
            border: 2px solid #C0CFDF;
            width: min(92vw, 420px)
        }

        #level-complete h2 {
            color: #2C3E50;
            margin-bottom: 8px
        }

        #level-complete p {
            color: #6B7C93;
            margin-bottom: 14px
        }
    </style>
</head>

<body>
    <noscript>
        <img height="1" width="1" style="display:none"
            src="https://www.facebook.com/tr?id=YOUR_META_PIXEL_ID&ev=PageView&noscript=1" />
    </noscript>
    <h1>NUMBER MATCH</h1>
    <div id="info-box"></div>
    <div id="hud">
        <span>Level <b id="h-level">1</b></span>
        <span>|</span>
        <span>Moves <b id="h-moves">0</b></span>
        <span>|</span>
        <span>Add-Rows <b id="h-adds">6</b></span>
        <span>|</span>
        <span>Corruptions <b id="h-corrupt">0</b></span>
        <span>|</span>
        <span>Remaining <b id="h-remain">0</b></span>
    </div>
    <div id="board-wrap">
        <div id="board"></div>
    </div>
    <div id="controls">
        <button id="btn-add">+ Add Row (<span id="add-count">6</span>)</button>
        <button id="btn-shuffle" class="shuffle-btn" style="display: none">Shuffle (50/50)</button>
        <button id="btn-hint">Hint</button>
        <button id="btn-restart">Restart Level</button>
        <label for="level-select">Level</label>
        <select id="level-select">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
            <option value="11">11</option>
            <option value="12">12</option>
            <option value="13">13</option>
            <option value="14">14</option>
            <option value="15">15</option>
            <option value="16">16</option>
            <option value="17">17</option>
            <option value="18">18</option>
            <option value="19">19</option>
            <option value="20">20</option>
        </select>
        <button id="btn-jump">Go</button>
    </div>
    <div id="msg"></div>
    <div id="level-complete">
        <div>
            <h2>Level Complete!</h2>
            <p id="lc-text"></p>
            <button id="btn-next">Next Level</button>
        </div>
    </div>

    <script>
        "use strict";

        // Guaranteed 100% solvable seeds (3 per level)
        // These were found by testing thousands of random seeds
        const SOLVABLE_SEEDS = {
            1: [123456, 654321, 999999], // Fallback simple seeds for level 1
            2: [234567, 765432, 888888], // Fallback simple seeds for level 2
            3: [903465, 423787, 294970],
            4: [519393, 579442, 470161],
            5: [145847, 564294, 352911],
            6: [708667, 552178, 699385],
            7: [361860, 294114, 227296],
            8: [507278, 212072, 951082],
            9: [427525, 479107, 184127],
            10: [183921, 146312, 951091]
        };

        const COLS = 9;

        /* ============================================================
           1. CONFIG TABLE â€” Sawtooth Difficulty (Levels 1-10)
           adjacentRatio : fraction of pairs placed side-by-side
           minSep/maxSep : swap distance range for separated pairs
           rows          : initial row count
           ============================================================ */
        const ConfigTable = {
            1: { adjacentRatio: .80, minSep: 2, maxSep: 4, rows: 3, targetTime: 45 },
            2: { adjacentRatio: .65, minSep: 3, maxSep: 6, rows: 3, targetTime: 65 },
            3: { adjacentRatio: .50, minSep: 3, maxSep: 8, rows: 3, targetTime: 90 },
            4: { adjacentRatio: .35, minSep: 4, maxSep: 10, rows: 3, targetTime: 120 },
            5: { adjacentRatio: .20, minSep: 5, maxSep: 13, rows: 4, targetTime: 150 },
            6: { adjacentRatio: .50, minSep: 3, maxSep: 8, rows: 4, targetTime: 90 }, // Relief
            7: { adjacentRatio: .30, minSep: 4, maxSep: 11, rows: 4, targetTime: 130 },
            8: { adjacentRatio: .22, minSep: 5, maxSep: 13, rows: 4, targetTime: 155 },
            9: { adjacentRatio: .15, minSep: 6, maxSep: 15, rows: 4, targetTime: 175 },
            10: { adjacentRatio: .10, minSep: 7, maxSep: 17, rows: 4, targetTime: 200 },
        };

        /* ============================================================
           2. SEEDED PRNG â€” Mulberry32 (replaces Math.random entirely)
           ============================================================ */
        function mulberry32(seed) {
            return function () {
                seed |= 0; seed = seed + 0x6D2B79F5 | 0;
                let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        /* ============================================================
           3. GAME STATE
           ============================================================ */
        const G = {
            grid: [],           // flat array, 0 = cleared/empty
            rows: 0,
            level: 1,
            moves: 0,
            addRowsLeft: 6,
            selected: -1,       // index of first-selected cell
            addWithoutMatch: 0,  // frustration counter (adds without any match)
            seed: 1,
            animating: false,    // lock during match animation
            corruptions: [],     // [{value, rescued: bool, rescuePartner}]
            rescueQueue: [],     // Queue of rescue operations
            rowsAddedForCurrentRescue: 0,  // Track friction for level 5+
            shufflesLeft: 0,     // Shuffle attempts available (level 2+, capped)
            shufflesUsed: 0,     // Track number of shuffles used
            totalRowsAdded: 0    // Track total rows added for quality improvement
        };

        /* ============================================================
           4. PAIR LOGIC â€” same number OR sum-to-10
           ============================================================ */
        function isPair(a, b) {
            if (a < 1 || a > 9 || b < 1 || b > 9) return false;
            return a === b || a + b === 10;
        }

        /* ============================================================
           5. PATH VALIDATION (Number Match rules)
           Two non-zero cells (i, j) can match if isPair AND:
             (a) 2D-adjacent (H/V/D â€” row/col each differ by â‰¤1), OR
             (b) All cells between them in the flat linear sequence are 0
                 (forward direction), OR
             (c) All cells in the wrap-around direction are 0
                 (from hiâ†’end, then startâ†’lo).
           ============================================================ */
        function areAdjacent(i, j) {
            const r1 = (i / COLS) | 0, c1 = i % COLS;
            const r2 = (j / COLS) | 0, c2 = j % COLS;
            return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1;
        }

        function canMatch(grid, i, j) {
            if (i === j) return false;
            const a = grid[i], b = grid[j];
            if (a === 0 || b === 0) return false;
            if (!isPair(a, b)) return false;

            // (a) 2D adjacency (H, V, D â€” one step)
            if (areAdjacent(i, j)) return true;

            const c1 = i % COLS, c2 = j % COLS;
            const r1 = (i / COLS) | 0, r2 = (j / COLS) | 0;

            // (b) Vertical path: same column, all cells between in column are 0
            if (c1 === c2) {
                const loR = Math.min(r1, r2), hiR = Math.max(r1, r2);
                let colOk = true;
                for (let r = loR + 1; r < hiR; r++) {
                    if (grid[r * COLS + c1] !== 0) { colOk = false; break; }
                }
                if (colOk) return true;
            }

            // (c) Horizontal path: same row, all cells between in row are 0
            if (r1 === r2) {
                const loC = Math.min(c1, c2), hiC = Math.max(c1, c2);
                let rowOk = true;
                for (let c = loC + 1; c < hiC; c++) {
                    if (grid[r1 * COLS + c] !== 0) { rowOk = false; break; }
                }
                if (rowOk) return true;
            }

            // (d) Diagonal paths: cells on same diagonal line with empty cells between
            const rowDiff = Math.abs(r2 - r1);
            const colDiff = Math.abs(c2 - c1);

            // Check if on same diagonal (slope = 1 or -1)
            if (rowDiff === colDiff && rowDiff > 1) {
                const rowStep = r2 > r1 ? 1 : -1;
                const colStep = c2 > c1 ? 1 : -1;
                let diagOk = true;

                let r = r1 + rowStep;
                let c = c1 + colStep;
                while (r !== r2 && c !== c2) {
                    if (grid[r * COLS + c] !== 0) {
                        diagOk = false;
                        break;
                    }
                    r += rowStep;
                    c += colStep;
                }

                if (diagOk) return true;
            }

            const lo = Math.min(i, j), hi = Math.max(i, j);

            // (e) Forward linear: every cell between lo and hi is 0
            let ok = true;
            for (let k = lo + 1; k < hi; k++) {
                if (grid[k] !== 0) { ok = false; break; }
            }
            if (ok) return true;

            return false;
        }

        /* ============================================================
           6. FIND ALL VALID MOVES
           ============================================================ */
        function findAllMoves(grid) {
            const moves = [];
            const live = [];
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] !== 0) live.push(i);
            }
            for (let a = 0; a < live.length; a++) {
                for (let b = a + 1; b < live.length; b++) {
                    if (canMatch(grid, live[a], live[b])) {
                        moves.push([live[a], live[b]]);
                    }
                }
            }
            return moves;
        }

        /* ============================================================
           7. GREEDY SOLVER â€” O(nÂ³), no backtracking
           Always picks the closest valid match. Returns true if
           the board can be fully cleared with this strategy.
           ============================================================ */
        function greedySolve(gridIn) {
            const g = gridIn.slice();
            for (let step = 0; step < 500; step++) {
                // Trim trailing zeros
                while (g.length > 0 && g[g.length - 1] === 0) g.pop();

                // Count remaining
                let remaining = 0;
                for (let i = 0; i < g.length; i++) { if (g[i] !== 0) remaining++; }
                if (remaining === 0) return true;

                const moves = findAllMoves(g);
                if (moves.length === 0) return false;

                // Pick the move with smallest linear distance
                let bestIdx = 0, bestDist = Infinity;
                for (let m = 0; m < moves.length; m++) {
                    const d = Math.abs(moves[m][0] - moves[m][1]);
                    if (d < bestDist) { bestDist = d; bestIdx = m; }
                }

                g[moves[bestIdx][0]] = 0;
                g[moves[bestIdx][1]] = 0;
            }
            return false;
        }

        /* ============================================================
           8. CORRUPTION-BASED BOARD GENERATOR
           Strategy: Intentional Impossible Numbers
           1) Inject exactly X corruptions (X = level)
           2) Fill remaining cells with perfect pairs
           3) Corruptions force Add Row usage
           4) Higher levels = more corruptions = more rows needed
           ============================================================ */
        function hasPartnerOnBoard(grid, value, excludeIndices = []) {
            const partner1 = value;
            const partner2 = 10 - value;

            for (let i = 0; i < grid.length; i++) {
                if (excludeIndices.includes(i)) continue;
                if (grid[i] === 0) continue;
                if (grid[i] === partner1 || grid[i] === partner2) {
                    return true;
                }
            }
            return false;
        }

        function buildUnrescuedCorruptionCountMap(corruptions) {
            const counts = {};
            for (let i = 0; i < corruptions.length; i++) {
                const c = corruptions[i];
                if (!c.rescued) {
                    counts[c.value] = (counts[c.value] || 0) + 1;
                }
            }
            return counts;
        }

        function markCorruptionsRescuedByMatch(corruptions, a, b) {
            const matched = {};
            matched[a] = (matched[a] || 0) + 1;
            matched[b] = (matched[b] || 0) + 1;

            for (let i = 0; i < corruptions.length; i++) {
                const c = corruptions[i];
                if (c.rescued) continue;
                if ((matched[c.value] || 0) > 0) {
                    c.rescued = true;
                    matched[c.value]--;
                }
            }
        }

        function chooseSpacedCorruptionSlots(count, rows, cols, rng) {
            const totalSlots = rows * cols;
            const allSlots = [];
            for (let i = 0; i < totalSlots; i++) allSlots.push(i);

            // Shuffle once for randomness and stable tie-breaking.
            for (let i = allSlots.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [allSlots[i], allSlots[j]] = [allSlots[j], allSlots[i]];
            }

            const chosen = [];
            for (let minDist = 3; minDist >= 1 && chosen.length < count; minDist--) {
                for (let i = 0; i < allSlots.length && chosen.length < count; i++) {
                    const slot = allSlots[i];
                    if (chosen.includes(slot)) continue;

                    const row = Math.floor(slot / cols);
                    const col = slot % cols;
                    let ok = true;
                    for (let c = 0; c < chosen.length; c++) {
                        const other = chosen[c];
                        const orow = Math.floor(other / cols);
                        const ocol = other % cols;
                        const md = Math.abs(row - orow) + Math.abs(col - ocol);
                        if (md < minDist) {
                            ok = false;
                            break;
                        }
                    }
                    if (ok) chosen.push(slot);
                }
            }

            while (chosen.length < count && chosen.length < totalSlots) {
                let bestSlot = -1;
                let bestMinDist = -1;
                for (let i = 0; i < allSlots.length; i++) {
                    const slot = allSlots[i];
                    if (chosen.includes(slot)) continue;
                    const row = Math.floor(slot / cols);
                    const col = slot % cols;
                    let minSeen = Number.POSITIVE_INFINITY;
                    for (let c = 0; c < chosen.length; c++) {
                        const other = chosen[c];
                        const orow = Math.floor(other / cols);
                        const ocol = other % cols;
                        const md = Math.abs(row - orow) + Math.abs(col - ocol);
                        if (md < minSeen) minSeen = md;
                    }
                    if (chosen.length === 0) minSeen = Number.POSITIVE_INFINITY;
                    if (minSeen > bestMinDist) {
                        bestMinDist = minSeen;
                        bestSlot = slot;
                    }
                }
                if (bestSlot === -1) break;
                chosen.push(bestSlot);
            }

            return chosen;
        }

        function pickNonAdjacentCorruptionValue(grid, idx, rng) {
            const adjacentValues = [];
            const col = idx % COLS;
            if (col > 0 && grid[idx - 1] > 0) adjacentValues.push(grid[idx - 1]);
            if (col < COLS - 1 && grid[idx + 1] > 0) adjacentValues.push(grid[idx + 1]);
            if (idx >= COLS && grid[idx - COLS] > 0) adjacentValues.push(grid[idx - COLS]);
            if (idx + COLS < grid.length && grid[idx + COLS] > 0) adjacentValues.push(grid[idx + COLS]);

            const valid = [];
            for (let candidate = 1; candidate <= 9; candidate++) {
                let conflict = false;
                for (let i = 0; i < adjacentValues.length; i++) {
                    if (isPair(candidate, adjacentValues[i])) {
                        conflict = true;
                        break;
                    }
                }
                if (!conflict) valid.push(candidate);
            }

            if (valid.length > 0) {
                return valid[Math.floor(rng() * valid.length)];
            }

            // Fallback: minimize adjacent pair conflicts.
            let bestValue = 1;
            let bestScore = Number.POSITIVE_INFINITY;
            for (let candidate = 1; candidate <= 9; candidate++) {
                let score = 0;
                for (let i = 0; i < adjacentValues.length; i++) {
                    if (isPair(candidate, adjacentValues[i])) score++;
                }
                if (score < bestScore || (score === bestScore && rng() < 0.5)) {
                    bestScore = score;
                    bestValue = candidate;
                }
            }
            return bestValue;
        }

        /* ============================================================
           NEW: LAYERED PUZZLE GENERATOR (Senior Dev Revision)
           Creates explicit dependency chains by placing blocking pairs.
           ============================================================ */
        function generateLayeredBoard(level) {
            const rng = mulberry32(G.seed++);

            let initialRows = 3;
            if (level >= 4) initialRows = 4;
            if (level >= 6) initialRows = 5;
            if (level >= 8) initialRows = 6;
            if (level >= 10) initialRows = 7;

            const totalCells = initialRows * COLS;
            const grid = new Array(totalCells).fill(0);
            const occupied = new Set();

            G.corruptions = [];
            G.rescueQueue = [];
            G.rowsAddedForCurrentRescue = 0;

            const layers = 1 + Math.floor(level / 2);
            const maxPlacementAttempts = 30;

            // --- PHASE 1: Build layered dependency core ---
            for (let i = 0; i < layers; i++) {
                let attempts = 0;
                let placedLayer = false;
                while (attempts < maxPlacementAttempts && !placedLayer) {
                    const idx1 = Math.floor(rng() * totalCells);
                    const idx2 = Math.floor(rng() * totalCells);
                    const dist = Math.abs(idx1 - idx2);

                    if (!occupied.has(idx1) && !occupied.has(idx2) && idx1 !== idx2 && dist > COLS) {
                        const midPoint = Math.round((idx1 + idx2) / 2);
                        let blockerIdx = -1;

                        for (let offset = 0; offset < COLS; offset++) {
                            const hi = midPoint + offset;
                            const lo = midPoint - offset;
                            if (hi < totalCells && !occupied.has(hi)) {
                                blockerIdx = hi;
                                break;
                            }
                            if (lo >= 0 && !occupied.has(lo)) {
                                blockerIdx = lo;
                                break;
                            }
                        }

                        if (blockerIdx !== -1 && blockerIdx !== idx1 && blockerIdx !== idx2 && !occupied.has(blockerIdx)) {
                            const goalValue = 1 + Math.floor(rng() * 9);
                            const blockerValue = 1 + Math.floor(rng() * 9);

                            grid[idx1] = goalValue;
                            grid[idx2] = goalValue;
                            occupied.add(idx1);
                            occupied.add(idx2);

                            grid[blockerIdx] = blockerValue;
                            occupied.add(blockerIdx);

                            const partnerPos = blockerIdx + 1;
                            if (partnerPos < totalCells && !occupied.has(partnerPos)) {
                                grid[partnerPos] = blockerValue;
                                occupied.add(partnerPos);
                            } else {
                                let fallbackPos = -1;
                                for (let p = 0; p < totalCells; p++) {
                                    if (!occupied.has(p)) {
                                        fallbackPos = p;
                                        break;
                                    }
                                }
                                if (fallbackPos !== -1) {
                                    grid[fallbackPos] = blockerValue;
                                    occupied.add(fallbackPos);
                                }
                            }

                            placedLayer = true;
                        }
                    }
                    attempts++;
                }
            }

            // --- PHASE 2: Fill remaining space naturally ---
            const emptyIndices = [];
            for (let i = 0; i < totalCells; i++) {
                if (!occupied.has(i)) emptyIndices.push(i);
            }
            for (let i = emptyIndices.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [emptyIndices[i], emptyIndices[j]] = [emptyIndices[j], emptyIndices[i]];
            }
            for (let i = 0; i < emptyIndices.length - 1; i += 2) {
                const val = 1 + Math.floor(rng() * 9);
                grid[emptyIndices[i]] = val;
                grid[emptyIndices[i + 1]] = val;
            }

            // --- PHASE 3: Append corruptions below natural grid ---
            const corruptionCount = getCorruptionCount(level);
            if (corruptionCount > 0) {
                const extraRows = Math.ceil(corruptionCount / COLS);
                const appendedStart = grid.length;
                for (let i = 0; i < extraRows * COLS; i++) grid.push(0);

                const slots = chooseSpacedCorruptionSlots(corruptionCount, extraRows, COLS, rng);
                for (let i = 0; i < slots.length; i++) {
                    const slot = slots[i];
                    const targetIdx = appendedStart + slot;
                    const corruptValue = pickNonAdjacentCorruptionValue(grid, targetIdx, rng);
                    grid[targetIdx] = corruptValue;
                    const rescuePartner = rng() < 0.5 ? corruptValue : (10 - corruptValue);
                    G.corruptions.push({
                        value: corruptValue,
                        rescued: false,
                        rescuePartner: rescuePartner,
                        decoyRowsNeeded: Math.floor(level / 4)
                    });
                }
            }

            return grid;
        }

        // Alias for compatibility
        function generateDeterministicBoard(level) {
            return generateLayeredBoard(level);
        }

        function generateFallbackBoard(level) {
            const cfg = ConfigTable[level] || ConfigTable[1];
            const totalCells = cfg.rows * COLS;
            const grid = [];
            while (grid.length + 1 < totalCells) {
                const n = ((grid.length / 2) | 0) % 9 + 1;
                grid.push(n, n);
            }
            while (grid.length < totalCells) grid.push(0);
            return grid;
        }

        /* ============================================================
           9. STRAGGLER DETECTOR â€” finds "loner" numbers whose
           pair-partner has been entirely cleared from the board
           ============================================================ */
        function calculateStragglers() {
            // Count occurrences of each value
            const counts = new Array(10).fill(0); // index 1-9
            for (let i = 0; i < G.grid.length; i++) {
                const v = G.grid[i];
                if (v >= 1 && v <= 9) counts[v]++;
            }

            const loners = [];
            for (let n = 1; n <= 9; n++) {
                if (counts[n] === 0) continue;

                const partner = 10 - n;
                const sameAvail = counts[n]; // how many of this number exist
                const partnerAvail = (partner !== n) ? counts[partner] : 0;

                // A number is a loner if:
                // - It appears an odd number of times (one can't self-pair)
                // - AND it has no sum-to-10 partner on the board
                if (partner === n) {
                    // Self-pairing (n=5): odd count means one is stranded
                    if (sameAvail % 2 === 1) loners.push(n);
                } else {
                    // sameAvail can self-pair in groups of 2; remainder needs partner
                    const remainder = sameAvail % 2;
                    if (remainder > 0 && partnerAvail === 0) loners.push(n);
                }
            }
            return loners;
        }

        function counterValue(value) {
            return value === 5 ? 5 : (10 - value);
        }

        function buildFinalRescueNumbers(remainingValues, rng) {
            const numbers = [];

            // Add exact counters for the final two values.
            for (let i = 0; i < remainingValues.length; i++) {
                numbers.push(counterValue(remainingValues[i]));
            }

            // Add one dummy valid pair (same number or sum-to-10 pair).
            const dummyLeft = 1 + Math.floor(rng() * 9);
            const dummyRight = counterValue(dummyLeft);
            numbers.push(dummyLeft, dummyRight);

            return numbers;
        }

        function buildEndgameRescueNumbers(remainingValues, rng) {
            const numbers = [];

            // Add one exact counter for each remaining number.
            for (let i = 0; i < remainingValues.length; i++) {
                numbers.push(counterValue(remainingValues[i]));
            }

            // Add one dummy valid pair to keep placement robust.
            const dummyLeft = 1 + Math.floor(rng() * 9);
            const dummyRight = counterValue(dummyLeft);
            numbers.push(dummyLeft, dummyRight);

            return numbers;
        }

        function getCorruptionCount(level) {
            if (level < 2) return 0;
            // Smooth but harder progression than the previous linear formula.
            return Math.floor((level - 1) * 2.2);
        }

        /* ============================================================
           10. SMART ADD ROW WITH LAYERED DECOYS
           For corruptions, adds decoy rows first, then rescue in later row
           ============================================================ */
        function addRow() {
            if (G.addRowsLeft <= 0) return;
            G.addRowsLeft--;
            G.totalRowsAdded++;
            trackEvent('add_row', { level: G.level, add_rows_left: G.addRowsLeft });

            const rng = mulberry32(G.seed++);
            const newRow = new Array(COLS).fill(0);
            const remainingValues = [];

            // --- Analyze board for stuck numbers ---
            const stuckNumbers = {};
            for (let i = 0; i < G.grid.length; i++) {
                if (G.grid[i] === 0) continue;

                const value = G.grid[i];
                remainingValues.push(value);
                let hasAdjacentPartner = false;

                // Check all 4 directions
                const col = i % COLS;
                if (col > 0 && isPair(value, G.grid[i - 1])) hasAdjacentPartner = true;
                if (col < COLS - 1 && isPair(value, G.grid[i + 1])) hasAdjacentPartner = true;
                if (i >= COLS && isPair(value, G.grid[i - COLS])) hasAdjacentPartner = true;
                if (i + COLS < G.grid.length && isPair(value, G.grid[i + COLS])) hasAdjacentPartner = true;

                if (!hasAdjacentPartner) {
                    stuckNumbers[value] = (stuckNumbers[value] || 0) + 1;
                }
            }

            // --- Handle Corruption Rescue with Decoy Layers ---
            const unrescuedCorruptions = G.corruptions.filter(c => !c.rescued);
            let isRescueRow = false;
            let rescueNumber = null;
            const isFinalRescueScenario = remainingValues.length === 2;
            const isThreeEndgameScenario = unrescuedCorruptions.length === 0 && remainingValues.length === 3;

            if (!isFinalRescueScenario && unrescuedCorruptions.length > 0) {
                const corruption = unrescuedCorruptions[0];

                // Track decoy rows added for this corruption
                if (!corruption.decoyRowsAdded) corruption.decoyRowsAdded = 0;

                const decoyRowsNeeded = corruption.decoyRowsNeeded || 0;

                if (corruption.decoyRowsAdded < decoyRowsNeeded) {
                    // Add DECOY row (pairs that block the rescue)
                    corruption.decoyRowsAdded++;
                    setMsg(`Decoy layer ${corruption.decoyRowsAdded}/${decoyRowsNeeded} added. Clear pairs to progress!`);
                } else {
                    // Add RESCUE row
                    isRescueRow = true;
                    rescueNumber = corruption.rescuePartner;
                    corruption.rescued = true;
                    setMsg(`Rescue number ${rescueNumber} found! Match with corruption ${corruption.value}!`);
                }
            }

            // --- Build Row with Natural Distribution ---
            const numbers = [];

            if (isFinalRescueScenario) {
                numbers.push(...buildFinalRescueNumbers(remainingValues, rng));
                setMsg(`Final rescue row: ${counterValue(remainingValues[0])}, ${counterValue(remainingValues[1])} + dummy pair.`);
            } else if (isThreeEndgameScenario) {
                numbers.push(...buildEndgameRescueNumbers(remainingValues, rng));
                setMsg(`Endgame rescue row added: counters for all 3 remaining numbers + dummy pair.`);
            } else if (isRescueRow && rescueNumber !== null) {
                // RESCUE ROW: Add rescue number PAIR + blocking pairs
                numbers.push(rescueNumber, rescueNumber); // Add as pair to ensure even count

                // Add 1-2 blocking pairs around it (layered difficulty)
                const blockingPairs = 1 + Math.floor(rng() * 2);
                for (let i = 0; i < blockingPairs; i++) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            } else if (unrescuedCorruptions.length > 0) {
                // DECOY ROW: Add only pairs (no rescue yet)
                const decoyPairs = 3 + Math.floor(rng() * 2); // 3-4 pairs
                for (let i = 0; i < decoyPairs; i++) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            } else {
                // HELPFUL ROW: Add partners for stuck numbers
                const stuckList = Object.keys(stuckNumbers).map(k => parseInt(k, 10));
                // In endgame, cover all remaining stuck values so no value is ignored (e.g. 9 -> 1).
                const helpCount = remainingValues.length <= 6
                    ? stuckList.length
                    : Math.min(3, stuckList.length);

                for (let i = 0; i < helpCount; i++) {
                    const stuckValue = stuckList[i];
                    const partner = stuckValue === 5 ? 5 : (10 - stuckValue);
                    numbers.push(partner, partner); // Add as pair
                }

                // Fill rest with random pairs if space
                while (numbers.length < 6 && rng() < 0.6) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            }

            // --- Humanized Placement (Natural Clustering) ---
            // Shuffle numbers
            for (let i = numbers.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
            }

            // Place with natural spacing (70-90% fill)
            let numIdx = 0;
            for (let col = 0; col < COLS && numIdx < numbers.length; col++) {
                const fillChance = (isFinalRescueScenario || isThreeEndgameScenario) ? 1.0 : (0.7 + rng() * 0.2);
                if (rng() < fillChance || col === COLS - 1) {
                    newRow[col] = numbers[numIdx++];
                }
            }

            // Append row to grid
            while (G.grid.length > 0 && G.grid[G.grid.length - 1] === 0) G.grid.pop();
            for (let i = 0; i < COLS; i++) G.grid.push(newRow[i]);
            G.rows = Math.ceil(G.grid.length / COLS);

            // Check for row collapse
            collapseEmptyRows();

            render();
            updateHUD();

            const moveCount = findAllMoves(G.grid).length;
            if (!isRescueRow && unrescuedCorruptions.length === 0) {
                setMsg(`Smart row added! ${moveCount} moves available.`);
            }
        }
        /* ============================================================
           ROW COLLAPSE â€” Remove completely empty rows and shift up
           ============================================================ */
        function collapseEmptyRows() {
            const rowCount = Math.ceil(G.grid.length / COLS);
            let collapsedAny = false;

            for (let row = rowCount - 1; row >= 0; row--) {
                const startIdx = row * COLS;
                const endIdx = startIdx + COLS;

                // Check if row is completely empty
                let isEmpty = true;
                for (let i = startIdx; i < endIdx && i < G.grid.length; i++) {
                    if (G.grid[i] !== 0) {
                        isEmpty = false;
                        break;
                    }
                }

                if (isEmpty) {
                    // Remove this row
                    G.grid.splice(startIdx, COLS);
                    G.rows = Math.ceil(G.grid.length / COLS);
                    collapsedAny = true;
                }
            }

            if (collapsedAny) {
                setMsg('Empty rows collapsed! Board compacted.');
            }
        }

        /* ============================================================
           11. SHUFFLE MECHANIC (Level 3+) â€” 50/50 Risk/Reward
           Progressive limit: L3=3, L4=4, L5=5, etc.
           ============================================================ */
        function cloneCorruptions(corruptions) {
            return corruptions.map(c => ({
                value: c.value,
                rescued: !!c.rescued,
                rescuePartner: c.rescuePartner,
                decoyRowsNeeded: c.decoyRowsNeeded || 0,
                decoyRowsAdded: c.decoyRowsAdded || 0
            }));
        }

        function solverCollapseEmptyRows(grid) {
            const out = grid.slice();
            const rowCount = Math.ceil(out.length / COLS);
            for (let row = rowCount - 1; row >= 0; row--) {
                const startIdx = row * COLS;
                const endIdx = startIdx + COLS;
                let isEmpty = true;
                for (let i = startIdx; i < endIdx && i < out.length; i++) {
                    if (out[i] !== 0) {
                        isEmpty = false;
                        break;
                    }
                }
                if (isEmpty) out.splice(startIdx, COLS);
            }
            return out;
        }

        function solverTrimTrailingEmptyRows(grid) {
            const out = grid.slice();
            while (out.length > COLS && isRowEmpty(out, out.length - COLS)) {
                out.length -= COLS;
            }
            return out;
        }

        function solverHasUnrescuedCorruptions(state) {
            const present = new Set();
            for (let i = 0; i < state.grid.length; i++) {
                const v = state.grid[i];
                if (v !== 0) present.add(v);
            }
            for (let i = 0; i < state.corruptions.length; i++) {
                const c = state.corruptions[i];
                if (!c.rescued && present.has(c.value)) return true;
            }
            return false;
        }

        function solverIsWin(state) {
            let remaining = 0;
            for (let i = 0; i < state.grid.length; i++) {
                if (state.grid[i] !== 0) remaining++;
            }
            if (solverHasUnrescuedCorruptions(state)) return false;
            return remaining <= 1;
        }

        function solverApplyMatch(state, i, j) {
            const next = {
                grid: state.grid.slice(),
                addRowsLeft: state.addRowsLeft,
                shufflesLeft: state.shufflesLeft,
                seed: state.seed,
                corruptions: cloneCorruptions(state.corruptions)
            };

            const valI = next.grid[i];
            const valJ = next.grid[j];
            markCorruptionsRescuedByMatch(next.corruptions, valI, valJ);

            next.grid[i] = 0;
            next.grid[j] = 0;
            next.grid = solverTrimTrailingEmptyRows(next.grid);
            next.grid = solverCollapseEmptyRows(next.grid);
            return next;
        }

        function solverApplyAddRow(state) {
            if (state.addRowsLeft <= 0) return null;
            const next = {
                grid: state.grid.slice(),
                addRowsLeft: state.addRowsLeft - 1,
                shufflesLeft: state.shufflesLeft,
                seed: state.seed + 1,
                corruptions: cloneCorruptions(state.corruptions)
            };

            const rng = mulberry32(state.seed);
            const newRow = new Array(COLS).fill(0);
            const remainingValues = [];

            const stuckNumbers = {};
            for (let i = 0; i < next.grid.length; i++) {
                if (next.grid[i] === 0) continue;
                const value = next.grid[i];
                remainingValues.push(value);
                let hasAdjacentPartner = false;
                const col = i % COLS;
                if (col > 0 && isPair(value, next.grid[i - 1])) hasAdjacentPartner = true;
                if (col < COLS - 1 && isPair(value, next.grid[i + 1])) hasAdjacentPartner = true;
                if (i >= COLS && isPair(value, next.grid[i - COLS])) hasAdjacentPartner = true;
                if (i + COLS < next.grid.length && isPair(value, next.grid[i + COLS])) hasAdjacentPartner = true;
                if (!hasAdjacentPartner) {
                    stuckNumbers[value] = (stuckNumbers[value] || 0) + 1;
                }
            }

            const unrescuedCorruptions = next.corruptions.filter(c => !c.rescued);
            let isRescueRow = false;
            let rescueNumber = null;
            const isFinalRescueScenario = remainingValues.length === 2;
            const isThreeEndgameScenario = unrescuedCorruptions.length === 0 && remainingValues.length === 3;
            if (!isFinalRescueScenario && unrescuedCorruptions.length > 0) {
                const corruption = unrescuedCorruptions[0];
                if (!corruption.decoyRowsAdded) corruption.decoyRowsAdded = 0;
                const decoyRowsNeeded = corruption.decoyRowsNeeded || 0;
                if (corruption.decoyRowsAdded < decoyRowsNeeded) {
                    corruption.decoyRowsAdded++;
                } else {
                    isRescueRow = true;
                    rescueNumber = corruption.rescuePartner;
                    corruption.rescued = true;
                }
            }

            const numbers = [];
            if (isFinalRescueScenario) {
                numbers.push(...buildFinalRescueNumbers(remainingValues, rng));
            } else if (isThreeEndgameScenario) {
                numbers.push(...buildEndgameRescueNumbers(remainingValues, rng));
            } else if (isRescueRow && rescueNumber !== null) {
                numbers.push(rescueNumber, rescueNumber);
                const blockingPairs = 1 + Math.floor(rng() * 2);
                for (let i = 0; i < blockingPairs; i++) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            } else if (unrescuedCorruptions.length > 0) {
                const decoyPairs = 3 + Math.floor(rng() * 2);
                for (let i = 0; i < decoyPairs; i++) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            } else {
                const stuckList = Object.keys(stuckNumbers).map(k => parseInt(k, 10));
                const helpCount = remainingValues.length <= 6
                    ? stuckList.length
                    : Math.min(3, stuckList.length);
                for (let i = 0; i < helpCount; i++) {
                    const stuckValue = stuckList[i];
                    const partner = stuckValue === 5 ? 5 : (10 - stuckValue);
                    numbers.push(partner, partner);
                }
                while (numbers.length < 6 && rng() < 0.6) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            }

            for (let i = numbers.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
            }

            let numIdx = 0;
            for (let col = 0; col < COLS && numIdx < numbers.length; col++) {
                const fillChance = (isFinalRescueScenario || isThreeEndgameScenario) ? 1.0 : (0.7 + rng() * 0.2);
                if (rng() < fillChance || col === COLS - 1) {
                    newRow[col] = numbers[numIdx++];
                }
            }

            while (next.grid.length > 0 && next.grid[next.grid.length - 1] === 0) next.grid.pop();
            for (let i = 0; i < COLS; i++) next.grid.push(newRow[i]);
            next.grid = solverCollapseEmptyRows(next.grid);
            return next;
        }

        function solverApplyShuffle(state) {
            if (state.shufflesLeft <= 0) return null;
            const next = {
                grid: state.grid.slice(),
                addRowsLeft: state.addRowsLeft,
                shufflesLeft: state.shufflesLeft - 1,
                seed: state.seed + 1,
                corruptions: cloneCorruptions(state.corruptions)
            };

            const rng = mulberry32(state.seed);
            const isGoodShuffle = rng() < 0.5;
            const cells = [];
            for (let i = 0; i < next.grid.length; i++) {
                if (next.grid[i] !== 0) cells.push({ index: i, value: next.grid[i] });
            }
            const positions = cells.map(c => c.index);
            const values = cells.map(c => c.value);
            if (positions.length === 0) return next;

            if (isGoodShuffle) {
                const newValues = [];
                const used = new Set();
                for (let i = 0; i < values.length; i++) {
                    if (used.has(i)) continue;
                    let foundPartner = false;
                    for (let j = i + 1; j < values.length; j++) {
                        if (used.has(j)) continue;
                        if (isPair(values[i], values[j])) {
                            newValues.push(values[i], values[j]);
                            used.add(i);
                            used.add(j);
                            foundPartner = true;
                            break;
                        }
                    }
                    if (!foundPartner) {
                        newValues.push(values[i]);
                        used.add(i);
                    }
                }

                const sortedPositions = positions.slice().sort((a, b) => a - b);
                const adjacentGroups = [];
                let currentGroup = [sortedPositions[0]];
                for (let i = 1; i < sortedPositions.length; i++) {
                    if (sortedPositions[i] - sortedPositions[i - 1] === 1) currentGroup.push(sortedPositions[i]);
                    else {
                        if (currentGroup.length > 0) adjacentGroups.push(currentGroup);
                        currentGroup = [sortedPositions[i]];
                    }
                }
                if (currentGroup.length > 0) adjacentGroups.push(currentGroup);

                const finalPositions = [];
                let valueIdx = 0;
                for (let g = 0; g < adjacentGroups.length; g++) {
                    const group = adjacentGroups[g];
                    for (let p = 0; p < group.length; p++) {
                        if (valueIdx < newValues.length) {
                            finalPositions.push({ pos: group[p], val: newValues[valueIdx++] });
                        }
                    }
                }

                for (let i = 0; i < cells.length; i++) next.grid[cells[i].index] = 0;
                for (let i = 0; i < finalPositions.length; i++) {
                    next.grid[finalPositions[i].pos] = finalPositions[i].val;
                }
            } else {
                for (let i = values.length - 1; i > 0; i--) {
                    const maxDist = Math.floor(i * 0.7);
                    const j = Math.max(0, i - maxDist) + Math.floor(rng() * (maxDist + 1));
                    [values[i], values[j]] = [values[j], values[i]];
                }
                for (let i = 0; i < cells.length; i++) next.grid[cells[i].index] = 0;
                for (let i = 0; i < positions.length; i++) next.grid[positions[i]] = values[i];
            }

            return next;
        }

        function solverStateKey(state) {
            const corruptionKey = state.corruptions
                .map(c => [c.value, c.rescued ? 1 : 0, c.rescuePartner, c.decoyRowsNeeded || 0, c.decoyRowsAdded || 0].join(','))
                .join(';');
            return state.addRowsLeft + '|' + state.shufflesLeft + '|' + state.seed + '|' +
                state.grid.join(',') + '|' + corruptionKey;
        }

        function isBoardSolvable(initialState) {
            const MAX_NODES = 30000;
            const MAX_DEPTH = 70;
            const MAX_MOVES_PER_STATE = 18;
            let nodes = 0;
            const memo = new Map();

            function dfs(state, depth) {
                if (solverIsWin(state)) return true;
                if (depth >= MAX_DEPTH) return false;
                nodes++;
                if (nodes > MAX_NODES) return false;

                const key = solverStateKey(state);
                if (memo.has(key)) return memo.get(key);

                const moves = findAllMoves(state.grid);
                moves.sort((a, b) => Math.abs(a[0] - a[1]) - Math.abs(b[0] - b[1]));
                const moveLimit = Math.min(MAX_MOVES_PER_STATE, moves.length);

                for (let i = 0; i < moveLimit; i++) {
                    const m = moves[i];
                    if (dfs(solverApplyMatch(state, m[0], m[1]), depth + 1)) {
                        memo.set(key, true);
                        return true;
                    }
                }

                if (state.addRowsLeft > 0) {
                    const addState = solverApplyAddRow(state);
                    if (addState && dfs(addState, depth + 1)) {
                        memo.set(key, true);
                        return true;
                    }
                }

                if (state.shufflesLeft > 0) {
                    const shuffleState = solverApplyShuffle(state);
                    if (shuffleState && dfs(shuffleState, depth + 1)) {
                        memo.set(key, true);
                        return true;
                    }
                }

                memo.set(key, false);
                return false;
            }

            return dfs(initialState, 0);
        }

        function shuffleBoard() {
            if (G.shufflesLeft <= 0 || G.animating) return;
            G.shufflesLeft--;
            G.shufflesUsed++;
            G.animating = true;

            const rng = mulberry32(G.seed++);
            const isGoodShuffle = rng() < 0.5; // 50% chance

            // Get all non-zero cell indices and values
            const cells = [];
            for (let i = 0; i < G.grid.length; i++) {
                if (G.grid[i] !== 0) {
                    cells.push({ index: i, value: G.grid[i] });
                }
            }

            // Store original positions and values
            const positions = cells.map(c => c.index);
            const values = cells.map(c => c.value);

            if (isGoodShuffle) {
                // GOOD SHUFFLE: Group pairs closer together
                setMsg('Lucky! Pairs moving closer together...');

                // Build a new arrangement that groups pairs
                const newValues = [];
                const used = new Set();

                // Find pairs and group them together in the values array
                for (let i = 0; i < values.length; i++) {
                    if (used.has(i)) continue;

                    // Find a partner for this value
                    let foundPartner = false;
                    for (let j = i + 1; j < values.length; j++) {
                        if (used.has(j)) continue;

                        if (isPair(values[i], values[j])) {
                            // Found a pair! Add them consecutively
                            newValues.push(values[i]);
                            newValues.push(values[j]);
                            used.add(i);
                            used.add(j);
                            foundPartner = true;
                            break;
                        }
                    }

                    // If no partner found, add the value anyway
                    if (!foundPartner) {
                        newValues.push(values[i]);
                        used.add(i);
                    }
                }

                // Now shuffle positions to try to place consecutive pairs adjacently
                // Sort positions to find adjacent slots
                const sortedPositions = [...positions].sort((a, b) => a - b);
                const adjacentGroups = [];
                let currentGroup = [sortedPositions[0]];

                for (let i = 1; i < sortedPositions.length; i++) {
                    if (sortedPositions[i] - sortedPositions[i - 1] === 1) {
                        currentGroup.push(sortedPositions[i]);
                    } else {
                        if (currentGroup.length > 0) adjacentGroups.push(currentGroup);
                        currentGroup = [sortedPositions[i]];
                    }
                }
                if (currentGroup.length > 0) adjacentGroups.push(currentGroup);

                // Place pairs in adjacent groups when possible
                const finalPositions = [];
                let valueIdx = 0;
                for (const group of adjacentGroups) {
                    for (const pos of group) {
                        if (valueIdx < newValues.length) {
                            finalPositions.push({ pos: pos, val: newValues[valueIdx++] });
                        }
                    }
                }

                // Clear all positions and place shuffled values
                for (const cell of cells) {
                    G.grid[cell.index] = 0;
                }
                for (const item of finalPositions) {
                    G.grid[item.pos] = item.val;
                }
            } else {
                // BAD SHUFFLE: Scatter pairs far apart
                setMsg('Unlucky! Pairs scattered apart...');

                // Fisher-Yates shuffle with bias toward distance
                for (let i = values.length - 1; i > 0; i--) {
                    // Bias toward swapping with distant elements
                    const maxDist = Math.floor(i * 0.7);
                    const j = Math.max(0, i - maxDist) + Math.floor(rng() * (maxDist + 1));
                    [values[i], values[j]] = [values[j], values[i]];
                }

                // Clear old positions and place shuffled values
                for (const cell of cells) {
                    G.grid[cell.index] = 0;
                }
                for (let i = 0; i < positions.length; i++) {
                    G.grid[positions[i]] = values[i];
                }
            }

            // Animate shuffle effect
            render();
            updateHUD();

            setTimeout(() => {
                G.animating = false;
                const moveCount = findAllMoves(G.grid).length;
                setMsg((isGoodShuffle ? 'Good shuffle! ' : 'Bad shuffle! ') +
                    moveCount + ' moves available. Shuffles left: ' + G.shufflesLeft);
            }, 500);
        }

        /* ============================================================
           12. GAME ACTIONS â€” select, match, hint
           ============================================================ */
        function selectCell(index) {
            if (G.animating) return;
            if (index < 0 || index >= G.grid.length) return;
            if (G.grid[index] === 0) return;

            // First selection
            if (G.selected === -1) {
                G.selected = index;
                render();
                return;
            }

            // Deselect
            if (G.selected === index) {
                G.selected = -1;
                render();
                return;
            }

            // Attempt match
            if (canMatch(G.grid, G.selected, index)) {
                const i = G.selected, j = index;
                const valI = G.grid[i];
                const valJ = G.grid[j];
                G.animating = true;
                G.selected = -1;

                // Mark matched corruption instances as rescued (count-aware).
                const beforeUnrescued = G.corruptions.filter(c => !c.rescued).length;
                markCorruptionsRescuedByMatch(G.corruptions, valI, valJ);
                const afterUnrescued = G.corruptions.filter(c => !c.rescued).length;
                if (afterUnrescued < beforeUnrescued) {
                    setMsg('Corruption rescued! ' + afterUnrescued + ' remaining.');
                }

                // Animate
                const cells = document.querySelectorAll('.cell');
                if (cells[i]) cells[i].classList.add('matched');
                if (cells[j]) cells[j].classList.add('matched');

                setTimeout(() => {
                    G.grid[i] = 0;
                    G.grid[j] = 0;
                    G.moves++;
                    G.addWithoutMatch = 0;

                    // Trim trailing empty rows
                    while (G.grid.length > COLS && isRowEmpty(G.grid, G.grid.length - COLS)) {
                        G.grid.length -= COLS;
                    }
                    G.rows = Math.ceil(G.grid.length / COLS);

                    // Collapse any empty rows and push lower rows up
                    collapseEmptyRows();

                    G.animating = false;
                    render();
                    updateHUD();
                    checkWin();
                }, 280);
            } else {
                // Invalid match â€” shake second cell
                const cells = document.querySelectorAll('.cell');
                if (cells[index]) cells[index].classList.add('invalid');
                setMsg('Not a valid match');
                G.selected = -1;
                setTimeout(() => {
                    render();
                    setMsg('');
                }, 400);
            }
        }

        function isRowEmpty(grid, startIdx) {
            for (let c = 0; c < COLS && startIdx + c < grid.length; c++) {
                if (grid[startIdx + c] !== 0) return false;
            }
            return true;
        }

        function checkWin() {
            let remaining = 0;
            const remainingValues = [];
            for (let i = 0; i < G.grid.length; i++) {
                if (G.grid[i] !== 0) {
                    remaining++;
                    remainingValues.push(G.grid[i]);
                }
            }

            // Check if any remaining numbers are unrescued corruptions
            const hasUnrescuedCorruptions = G.corruptions.some(c => {
                if (!c.rescued) {
                    // Check if this corruption value still exists on the board
                    return remainingValues.includes(c.value);
                }
                return false;
            });

            // Don't win if unrescued corruptions remain - they need rescue partners
            if (hasUnrescuedCorruptions) {
                return;
            }

            // Win if 0 or 1 numbers remain (1 number can't be paired)
            // AND all corruptions have been rescued
            if (remaining <= 1) {
                const addRowsUsed = (G.level >= 5 ? (10 + G.level * 2) : (6 + G.level)) - G.addRowsLeft;
                const shuffleText = G.level >= 2 && G.shufflesUsed > 0 ? ', ' + G.shufflesUsed + ' shuffles' : '';
                const perfection = remaining === 0 ? ' Perfect!' : '';
                const corruptionText = G.corruptions.length > 0 ? G.corruptions.length + ' corruptions rescued, ' : '';
                trackEvent('level_complete', {
                    level: G.level,
                    moves: G.moves,
                    add_rows_used: addRowsUsed,
                    remaining: remaining
                });
                document.getElementById('lc-text').textContent =
                    'Level ' + G.level + ' cleared!' + perfection + ' ' + G.moves + ' moves, ' +
                    corruptionText + addRowsUsed + ' rows added' + shuffleText + '.';
                document.getElementById('level-complete').classList.add('show');
            }
        }

        function showHint() {
            if (G.animating) return;
            G.selected = -1;

            const moves = findAllMoves(G.grid);
            if (moves.length === 0) {
                setMsg('No moves available \u2014 use + Add Row');
                return;
            }

            render(); // clear any previous selection highlight

            const [a, b] = moves[0];
            const cells = document.querySelectorAll('.cell');
            if (cells[a]) cells[a].classList.add('hint-glow');
            if (cells[b]) cells[b].classList.add('hint-glow');
            trackEvent('hint_used', { level: G.level });

            setMsg('Hint: row ' + (((a / COLS) | 0) + 1) + ' col ' + (a % COLS + 1) +
                '  &  row ' + (((b / COLS) | 0) + 1) + ' col ' + (b % COLS + 1));
        }

        /* ============================================================
           13. RENDERING
           ============================================================ */
        function getMinDisplayRows(level) {
            return level >= 5 ? 10 : 0;
        }

        function isCorruption(value, corruptionCounts) {
            if (value === 0) return false;
            if ((corruptionCounts[value] || 0) > 0) {
                corruptionCounts[value]--;
                return true;
            }
            return false;
        }

        function render() {
            const board = document.getElementById('board');
            // Pad grid to full rows
            while (G.grid.length % COLS !== 0) G.grid.push(0);
            G.rows = G.grid.length / COLS;
            const displayRows = Math.max(G.rows, getMinDisplayRows(G.level));
            const displayCells = displayRows * COLS;
            const corruptionCounts = buildUnrescuedCorruptionCountMap(G.corruptions);

            const frags = [];
            for (let i = 0; i < displayCells; i++) {
                const v = i < G.grid.length ? G.grid[i] : 0;
                const empty = v === 0;
                const sel = i === G.selected;

                let cls = 'cell';
                if (empty) cls += ' empty';
                else {
                    cls += ' num';
                    if (sel) cls += ' selected';
                }
                frags.push('<div class="' + cls + '" data-i="' + i + '">' +
                    (empty ? '' : v) + '</div>');
            }
            board.innerHTML = frags.join('');

            // Attach click handlers to number cells
            const numCells = board.querySelectorAll('.cell.num');
            for (let c = 0; c < numCells.length; c++) {
                numCells[c].addEventListener('click', handleCellClick);
            }
        }

        function handleCellClick(e) {
            selectCell(parseInt(e.currentTarget.dataset.i, 10));
        }

        function updateHUD() {
            let remaining = 0;
            for (let i = 0; i < G.grid.length; i++) {
                if (G.grid[i] !== 0) remaining++;
            }
            const unrescuedCorruptions = G.corruptions.filter(c => !c.rescued).length;
            document.getElementById('h-level').textContent = G.level;
            document.getElementById('h-moves').textContent = G.moves;
            document.getElementById('h-adds').textContent = G.addRowsLeft;
            document.getElementById('h-corrupt').textContent = unrescuedCorruptions;
            document.getElementById('h-remain').textContent = remaining;
            document.getElementById('add-count').textContent = G.addRowsLeft;
            document.getElementById('btn-add').disabled = G.addRowsLeft <= 0;

            // Update shuffle button
            if (G.level >= 2) {
                const shuffleBtn = document.getElementById('btn-shuffle');
                shuffleBtn.disabled = G.shufflesLeft <= 0;
                shuffleBtn.textContent = 'Shuffle (' + G.shufflesLeft + ')';
            }
        }

        function setMsg(t) { document.getElementById('msg').textContent = t; }

        function trackEvent(name, params = {}) {
            if (typeof gtag === 'function') gtag('event', name, params);
            if (typeof fbq === 'function') fbq('trackCustom', name, params);
        }

        /* ============================================================
           14. LEVEL MANAGEMENT
           ============================================================ */
        function startLevel(level) {
            G.level = level;
            G.moves = 0;
            G.addRowsLeft = level >= 5 ? (10 + level * 2) : (6 + level);
            G.shufflesLeft = level >= 2 ? 10 : 0;
            G.shufflesUsed = 0;
            G.selected = -1;
            G.addWithoutMatch = 0;
            G.animating = false;

            G.corruptions = [];
            G.rescueQueue = [];
            G.rowsAddedForCurrentRescue = 0;
            document.getElementById('level-select').value = String(level);

            const shuffleBtn = document.getElementById('btn-shuffle');
            if (level >= 2) shuffleBtn.style.display = 'inline-block';
            else shuffleBtn.style.display = 'none';
            trackEvent('level_start', { level: level });

            let initialRows = 3;
            if (level >= 4 && level <= 5) initialRows = 4;
            else if (level >= 6 && level <= 7) initialRows = 5;
            else if (level >= 8 && level <= 9) initialRows = 6;
            else if (level >= 10) initialRows = 7;

            const corruptionCount = getCorruptionCount(level);
            setMsg('Building layered puzzle (' + initialRows + ' rows, ' + corruptionCount + ' corruptions)...');

            setTimeout(function () {
                const levelSeeds = SOLVABLE_SEEDS[Math.min(level, 10)] || [0];
                const MAX_SOLVER_ATTEMPTS = 80;
                let found = false;
                let fallbackGrid = [];
                let fallbackCorruptions = [];
                let fallbackSeed = 1;

                for (let attempt = 0; attempt < MAX_SOLVER_ATTEMPTS; attempt++) {
                    const seedBase = levelSeeds[attempt % levelSeeds.length];
                    const candidateSeed = level * 31337 + seedBase + attempt * 7919;

                    G.seed = candidateSeed;
                    G.corruptions = [];
                    G.rescueQueue = [];
                    G.rowsAddedForCurrentRescue = 0;

                    const candidateGrid = generateLayeredBoard(level);
                    const candidateCorruptions = cloneCorruptions(G.corruptions);
                    const state = {
                        grid: candidateGrid.slice(),
                        addRowsLeft: G.addRowsLeft,
                        shufflesLeft: G.shufflesLeft,
                        seed: G.seed,
                        corruptions: cloneCorruptions(candidateCorruptions)
                    };

                    fallbackGrid = candidateGrid.slice();
                    fallbackCorruptions = candidateCorruptions;
                    fallbackSeed = G.seed;

                    if (isBoardSolvable(state)) {
                        G.grid = candidateGrid.slice();
                        G.corruptions = candidateCorruptions;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    G.grid = fallbackGrid;
                    G.corruptions = fallbackCorruptions;
                    G.seed = fallbackSeed;
                }

                G.rows = Math.ceil(G.grid.length / COLS);
                G.totalRowsAdded = 0;
                render();
                updateHUD();

                const moveCount = findAllMoves(G.grid).length;
                const unrescued = G.corruptions.filter(c => !c.rescued).length;
                const shuffleText = level >= 2 ? ' | 10 shuffles' : '';
                const layerHint = level >= 4 ? ' | Rescue needs ' + Math.floor(level / 4) + ' decoy rows' : '';
                const solverText = found ? ' | Solvable seed locked' : ' | Solver fallback';
                setMsg(moveCount + ' moves | ' + unrescued + ' corruptions' + shuffleText + layerHint + solverText + ' | Plan your moves!');
            }, 16);
        }

        function nextLevel() {
            document.getElementById('level-complete').classList.remove('show');
            startLevel(G.level < 20 ? G.level + 1 : 1);
        }

        /* ============================================================
           15. INIT
           ============================================================ */
        document.getElementById('btn-add').addEventListener('click', addRow);
        document.getElementById('btn-shuffle').addEventListener('click', shuffleBoard);
        document.getElementById('btn-hint').addEventListener('click', showHint);
        document.getElementById('btn-restart').addEventListener('click', function () { startLevel(G.level); });
        document.getElementById('btn-next').addEventListener('click', nextLevel);
        document.getElementById('btn-jump').addEventListener('click', function () {
            const v = parseInt(document.getElementById('level-select').value, 10);
            if (v >= 1 && v <= 20) startLevel(v);
        });
        document.getElementById('level-select').addEventListener('change', function () {
            const v = parseInt(this.value, 10);
            if (v >= 1 && v <= 20) startLevel(v);
        });

        startLevel(1);
    </script>
</body>

</html>
