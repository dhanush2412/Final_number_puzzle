<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Match â€” Deterministic Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0f0f13;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px
        }

        h1 {
            font-size: 1.4rem;
            margin-bottom: 4px;
            color: #a0a0ff;
            letter-spacing: 1px
        }

        #hud {
            display: flex;
            gap: 24px;
            margin: 8px 0 12px;
            font-size: .85rem;
            color: #888;
            flex-wrap: wrap;
            justify-content: center
        }

        #hud span {
            color: #ccc
        }

        #board-wrap {
            position: relative;
            overflow-y: auto;
            max-height: 70vh;
            border: 1px solid #2a2a3a;
            border-radius: 8px;
            padding: 4px;
            background: #16161e
        }

        #board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 3px;
            min-width: 340px
        }

        .cell {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: 700;
            border-radius: 6px;
            cursor: pointer;
            transition: background .12s, border-color .12s, box-shadow .12s;
            user-select: none
        }

        .cell.num {
            background: #1e1e2e;
            color: #d0d0e8;
            border: 2px solid #2a2a3a
        }

        .cell.num:hover {
            background: #2a2a4a;
            border-color: #5a5aaa
        }

        .cell.empty {
            background: transparent;
            border: 2px solid transparent;
            cursor: default
        }

        .cell.selected {
            background: #2e2e6a;
            border-color: #7a7aff;
            box-shadow: 0 0 10px #5a5aff44
        }

        .cell.matched {
            animation: pop .3s ease-out forwards
        }

        .cell.invalid {
            animation: shake .25s ease-out
        }

        .cell.hint-glow {
            animation: pulse .6s ease-in-out 2
        }

        .cell.corruption {
            background: #5a1212;
            border-color: #ff4d4d;
            color: #ffdcdc;
            box-shadow: 0 0 12px #ff2a2a66
        }

        .cell.corruption:hover {
            background: #6a1d1d;
            border-color: #ff7a7a
        }

        @keyframes pop {
            0% {
                transform: scale(1);
                opacity: 1
            }

            50% {
                transform: scale(1.25);
                opacity: .7
            }

            100% {
                transform: scale(0);
                opacity: 0
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0)
            }

            25% {
                transform: translateX(-4px)
            }

            75% {
                transform: translateX(4px)
            }
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 4px #ffaa0044
            }

            50% {
                box-shadow: 0 0 16px #ffaa00aa;
                border-color: #ffaa00
            }
        }

        #controls {
            display: flex;
            gap: 10px;
            margin-top: 12px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center
        }

        button {
            padding: 8px 16px;
            border: 1px solid #3a3a5a;
            border-radius: 6px;
            background: #1e1e2e;
            color: #c0c0e0;
            font-size: .82rem;
            cursor: pointer;
            transition: background .2s
        }

        button:hover:not(:disabled) {
            background: #2a2a4a
        }

        button:disabled {
            opacity: .3;
            cursor: not-allowed
        }

        button.shuffle-btn {
            background: linear-gradient(135deg, #2a2a4a 0%, #3a3a5a 100%);
            border: 1px solid #5a5a7a;
            position: relative;
            overflow: hidden
        }

        button.shuffle-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #3a3a6a 0%, #4a4a7a 100%);
            box-shadow: 0 0 12px #6a6aaa44
        }

        button.shuffle-btn::before {
            content: 'ðŸŽ²';
            margin-right: 4px
        }

        select {
            padding: 8px 10px;
            border: 1px solid #3a3a5a;
            border-radius: 6px;
            background: #1e1e2e;
            color: #c0c0e0;
            font-size: .82rem;
        }

        #msg {
            margin-top: 10px;
            font-size: .85rem;
            min-height: 1.4em;
            color: #8a8aaa;
            text-align: center
        }

        #level-complete {
            display: none;
            position: fixed;
            inset: 0;
            background: #000b;
            z-index: 10;
            flex-direction: column;
            align-items: center;
            justify-content: center
        }

        #level-complete.show {
            display: flex
        }

        #level-complete div {
            background: #1a1a2e;
            padding: 32px 48px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #3a3a6a
        }

        #level-complete h2 {
            color: #8a8aff;
            margin-bottom: 8px
        }

        #level-complete p {
            color: #aaa;
            margin-bottom: 16px
        }

        #info-box {
            background: #1a1a2a;
            border: 1px solid #3a3a5a;
            border-radius: 6px;
            padding: 8px 16px;
            margin: 8px 0;
            font-size: .75rem;
            color: #aaa;
            max-width: 500px;
            text-align: center
        }

        #info-box .corrupt-label {
            color: #aaa;
            font-weight: 700
        }
    </style>
</head>

<body>
    <h1>NUMBER MATCH</h1>
    <div id="info-box">
        <strong>ðŸ§© Layered Puzzle:</strong> Solve blocking pairs to unlock deeper pairs!
        <br><span style="font-size: .7rem"><span class="corrupt-label">Corruptions</span> need rescue via Add Row | L5+:
            Rescue hidden behind level-scaled decoy rows | Smart rows analyze & help | Empty rows collapse</span>
    </div>
    <div id="hud">
        Level <span id="h-level">1</span> &nbsp;|&nbsp;
        Moves <span id="h-moves">0</span> &nbsp;|&nbsp;
        Add-Rows <span id="h-adds">6</span> &nbsp;|&nbsp;
        Corruptions <span id="h-corrupt">0</span> &nbsp;|&nbsp;
        Remaining <span id="h-remain">0</span>
    </div>
    <div id="board-wrap">
        <div id="board"></div>
    </div>
    <div id="controls">
        <button id="btn-add">+ Add Row (<span id="add-count">6</span>)</button>
        <button id="btn-shuffle" class="shuffle-btn" style="display: none">Shuffle (50/50)</button>
        <button id="btn-hint">Hint</button>
        <button id="btn-restart">Restart Level</button>
        <label for="level-select">Level</label>
        <select id="level-select">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
            <option value="11">11</option>
            <option value="12">12</option>
            <option value="13">13</option>
            <option value="14">14</option>
            <option value="15">15</option>
            <option value="16">16</option>
            <option value="17">17</option>
            <option value="18">18</option>
            <option value="19">19</option>
            <option value="20">20</option>
        </select>
        <button id="btn-jump">Go</button>
    </div>
    <div id="msg"></div>
    <div id="level-complete">
        <div>
            <h2>Level Complete!</h2>
            <p id="lc-text"></p>
            <button id="btn-next">Next Level</button>
        </div>
    </div>

    <script>
        "use strict";

        // Guaranteed 100% solvable seeds (3 per level)
        // These were found by testing thousands of random seeds
        const SOLVABLE_SEEDS = {
            1: [123456, 654321, 999999], // Fallback simple seeds for level 1
            2: [234567, 765432, 888888], // Fallback simple seeds for level 2
            3: [903465, 423787, 294970],
            4: [519393, 579442, 470161],
            5: [145847, 564294, 352911],
            6: [708667, 552178, 699385],
            7: [361860, 294114, 227296],
            8: [507278, 212072, 951082],
            9: [427525, 479107, 184127],
            10: [183921, 146312, 951091]
        };

        const COLS = 9;

        /* ============================================================
           1. CONFIG TABLE â€” Sawtooth Difficulty (Levels 1-10)
           adjacentRatio : fraction of pairs placed side-by-side
           minSep/maxSep : swap distance range for separated pairs
           rows          : initial row count
           ============================================================ */
        const ConfigTable = {
            1: { adjacentRatio: .80, minSep: 2, maxSep: 4, rows: 3, targetTime: 45 },
            2: { adjacentRatio: .65, minSep: 3, maxSep: 6, rows: 3, targetTime: 65 },
            3: { adjacentRatio: .50, minSep: 3, maxSep: 8, rows: 3, targetTime: 90 },
            4: { adjacentRatio: .35, minSep: 4, maxSep: 10, rows: 3, targetTime: 120 },
            5: { adjacentRatio: .20, minSep: 5, maxSep: 13, rows: 4, targetTime: 150 },
            6: { adjacentRatio: .50, minSep: 3, maxSep: 8, rows: 4, targetTime: 90 }, // Relief
            7: { adjacentRatio: .30, minSep: 4, maxSep: 11, rows: 4, targetTime: 130 },
            8: { adjacentRatio: .22, minSep: 5, maxSep: 13, rows: 4, targetTime: 155 },
            9: { adjacentRatio: .15, minSep: 6, maxSep: 15, rows: 4, targetTime: 175 },
            10: { adjacentRatio: .10, minSep: 7, maxSep: 17, rows: 4, targetTime: 200 },
        };

        /* ============================================================
           2. SEEDED PRNG â€” Mulberry32 (replaces Math.random entirely)
           ============================================================ */
        function mulberry32(seed) {
            return function () {
                seed |= 0; seed = seed + 0x6D2B79F5 | 0;
                let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        /* ============================================================
           3. GAME STATE
           ============================================================ */
        const G = {
            grid: [],           // flat array, 0 = cleared/empty
            rows: 0,
            level: 1,
            moves: 0,
            addRowsLeft: 6,
            selected: -1,       // index of first-selected cell
            addWithoutMatch: 0,  // frustration counter (adds without any match)
            seed: 1,
            animating: false,    // lock during match animation
            corruptions: [],     // [{value, rescued: bool, rescuePartner}]
            rescueQueue: [],     // Queue of rescue operations
            rowsAddedForCurrentRescue: 0,  // Track friction for level 5+
            shufflesLeft: 0,     // Shuffle attempts available (level 2+, capped)
            shufflesUsed: 0,     // Track number of shuffles used
            totalRowsAdded: 0    // Track total rows added for quality improvement
        };

        /* ============================================================
           4. PAIR LOGIC â€” same number OR sum-to-10
           ============================================================ */
        function isPair(a, b) {
            if (a < 1 || a > 9 || b < 1 || b > 9) return false;
            return a === b || a + b === 10;
        }

        /* ============================================================
           5. PATH VALIDATION (Number Match rules)
           Two non-zero cells (i, j) can match if isPair AND:
             (a) 2D-adjacent (H/V/D â€” row/col each differ by â‰¤1), OR
             (b) All cells between them in the flat linear sequence are 0
                 (forward direction), OR
             (c) All cells in the wrap-around direction are 0
                 (from hiâ†’end, then startâ†’lo).
           ============================================================ */
        function areAdjacent(i, j) {
            const r1 = (i / COLS) | 0, c1 = i % COLS;
            const r2 = (j / COLS) | 0, c2 = j % COLS;
            return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1;
        }

        function canMatch(grid, i, j) {
            if (i === j) return false;
            const a = grid[i], b = grid[j];
            if (a === 0 || b === 0) return false;
            if (!isPair(a, b)) return false;

            // (a) 2D adjacency (H, V, D â€” one step)
            if (areAdjacent(i, j)) return true;

            const c1 = i % COLS, c2 = j % COLS;
            const r1 = (i / COLS) | 0, r2 = (j / COLS) | 0;

            // (b) Vertical path: same column, all cells between in column are 0
            if (c1 === c2) {
                const loR = Math.min(r1, r2), hiR = Math.max(r1, r2);
                let colOk = true;
                for (let r = loR + 1; r < hiR; r++) {
                    if (grid[r * COLS + c1] !== 0) { colOk = false; break; }
                }
                if (colOk) return true;
            }

            // (c) Horizontal path: same row, all cells between in row are 0
            if (r1 === r2) {
                const loC = Math.min(c1, c2), hiC = Math.max(c1, c2);
                let rowOk = true;
                for (let c = loC + 1; c < hiC; c++) {
                    if (grid[r1 * COLS + c] !== 0) { rowOk = false; break; }
                }
                if (rowOk) return true;
            }

            // (d) Diagonal paths: cells on same diagonal line with empty cells between
            const rowDiff = Math.abs(r2 - r1);
            const colDiff = Math.abs(c2 - c1);

            // Check if on same diagonal (slope = 1 or -1)
            if (rowDiff === colDiff && rowDiff > 1) {
                const rowStep = r2 > r1 ? 1 : -1;
                const colStep = c2 > c1 ? 1 : -1;
                let diagOk = true;

                let r = r1 + rowStep;
                let c = c1 + colStep;
                while (r !== r2 && c !== c2) {
                    if (grid[r * COLS + c] !== 0) {
                        diagOk = false;
                        break;
                    }
                    r += rowStep;
                    c += colStep;
                }

                if (diagOk) return true;
            }

            const lo = Math.min(i, j), hi = Math.max(i, j);

            // (e) Forward linear: every cell between lo and hi is 0
            let ok = true;
            for (let k = lo + 1; k < hi; k++) {
                if (grid[k] !== 0) { ok = false; break; }
            }
            if (ok) return true;

            return false;
        }

        /* ============================================================
           6. FIND ALL VALID MOVES
           ============================================================ */
        function findAllMoves(grid) {
            const moves = [];
            const live = [];
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] !== 0) live.push(i);
            }
            for (let a = 0; a < live.length; a++) {
                for (let b = a + 1; b < live.length; b++) {
                    if (canMatch(grid, live[a], live[b])) {
                        moves.push([live[a], live[b]]);
                    }
                }
            }
            return moves;
        }

        /* ============================================================
           7. GREEDY SOLVER â€” O(nÂ³), no backtracking
           Always picks the closest valid match. Returns true if
           the board can be fully cleared with this strategy.
           ============================================================ */
        function greedySolve(gridIn) {
            const g = gridIn.slice();
            for (let step = 0; step < 500; step++) {
                // Trim trailing zeros
                while (g.length > 0 && g[g.length - 1] === 0) g.pop();

                // Count remaining
                let remaining = 0;
                for (let i = 0; i < g.length; i++) { if (g[i] !== 0) remaining++; }
                if (remaining === 0) return true;

                const moves = findAllMoves(g);
                if (moves.length === 0) return false;

                // Pick the move with smallest linear distance
                let bestIdx = 0, bestDist = Infinity;
                for (let m = 0; m < moves.length; m++) {
                    const d = Math.abs(moves[m][0] - moves[m][1]);
                    if (d < bestDist) { bestDist = d; bestIdx = m; }
                }

                g[moves[bestIdx][0]] = 0;
                g[moves[bestIdx][1]] = 0;
            }
            return false;
        }

        /* ============================================================
           8. CORRUPTION-BASED BOARD GENERATOR
           Strategy: Intentional Impossible Numbers
           1) Inject exactly X corruptions (X = level)
           2) Fill remaining cells with perfect pairs
           3) Corruptions force Add Row usage
           4) Higher levels = more corruptions = more rows needed
           ============================================================ */
        function hasPartnerOnBoard(grid, value, excludeIndices = []) {
            const partner1 = value;
            const partner2 = 10 - value;

            for (let i = 0; i < grid.length; i++) {
                if (excludeIndices.includes(i)) continue;
                if (grid[i] === 0) continue;
                if (grid[i] === partner1 || grid[i] === partner2) {
                    return true;
                }
            }
            return false;
        }

        function buildUnrescuedCorruptionCountMap(corruptions) {
            const counts = {};
            for (let i = 0; i < corruptions.length; i++) {
                const c = corruptions[i];
                if (!c.rescued) {
                    counts[c.value] = (counts[c.value] || 0) + 1;
                }
            }
            return counts;
        }

        function markCorruptionsRescuedByMatch(corruptions, a, b) {
            const matched = {};
            matched[a] = (matched[a] || 0) + 1;
            matched[b] = (matched[b] || 0) + 1;

            for (let i = 0; i < corruptions.length; i++) {
                const c = corruptions[i];
                if (c.rescued) continue;
                if ((matched[c.value] || 0) > 0) {
                    c.rescued = true;
                    matched[c.value]--;
                }
            }
        }

        function chooseSpacedCorruptionSlots(count, rows, cols, rng) {
            const totalSlots = rows * cols;
            const allSlots = [];
            for (let i = 0; i < totalSlots; i++) allSlots.push(i);

            // Shuffle once for randomness and stable tie-breaking.
            for (let i = allSlots.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [allSlots[i], allSlots[j]] = [allSlots[j], allSlots[i]];
            }

            const chosen = [];
            for (let minDist = 3; minDist >= 1 && chosen.length < count; minDist--) {
                for (let i = 0; i < allSlots.length && chosen.length < count; i++) {
                    const slot = allSlots[i];
                    if (chosen.includes(slot)) continue;

                    const row = Math.floor(slot / cols);
                    const col = slot % cols;
                    let ok = true;
                    for (let c = 0; c < chosen.length; c++) {
                        const other = chosen[c];
                        const orow = Math.floor(other / cols);
                        const ocol = other % cols;
                        const md = Math.abs(row - orow) + Math.abs(col - ocol);
                        if (md < minDist) {
                            ok = false;
                            break;
                        }
                    }
                    if (ok) chosen.push(slot);
                }
            }

            while (chosen.length < count && chosen.length < totalSlots) {
                let bestSlot = -1;
                let bestMinDist = -1;
                for (let i = 0; i < allSlots.length; i++) {
                    const slot = allSlots[i];
                    if (chosen.includes(slot)) continue;
                    const row = Math.floor(slot / cols);
                    const col = slot % cols;
                    let minSeen = Number.POSITIVE_INFINITY;
                    for (let c = 0; c < chosen.length; c++) {
                        const other = chosen[c];
                        const orow = Math.floor(other / cols);
                        const ocol = other % cols;
                        const md = Math.abs(row - orow) + Math.abs(col - ocol);
                        if (md < minSeen) minSeen = md;
                    }
                    if (chosen.length === 0) minSeen = Number.POSITIVE_INFINITY;
                    if (minSeen > bestMinDist) {
                        bestMinDist = minSeen;
                        bestSlot = slot;
                    }
                }
                if (bestSlot === -1) break;
                chosen.push(bestSlot);
            }

            return chosen;
        }

        function pickNonAdjacentCorruptionValue(grid, idx, rng) {
            const adjacentValues = [];
            const col = idx % COLS;
            if (col > 0 && grid[idx - 1] > 0) adjacentValues.push(grid[idx - 1]);
            if (col < COLS - 1 && grid[idx + 1] > 0) adjacentValues.push(grid[idx + 1]);
            if (idx >= COLS && grid[idx - COLS] > 0) adjacentValues.push(grid[idx - COLS]);
            if (idx + COLS < grid.length && grid[idx + COLS] > 0) adjacentValues.push(grid[idx + COLS]);

            const valid = [];
            for (let candidate = 1; candidate <= 9; candidate++) {
                let conflict = false;
                for (let i = 0; i < adjacentValues.length; i++) {
                    if (isPair(candidate, adjacentValues[i])) {
                        conflict = true;
                        break;
                    }
                }
                if (!conflict) valid.push(candidate);
            }

            if (valid.length > 0) {
                return valid[Math.floor(rng() * valid.length)];
            }

            // Fallback: minimize adjacent pair conflicts.
            let bestValue = 1;
            let bestScore = Number.POSITIVE_INFINITY;
            for (let candidate = 1; candidate <= 9; candidate++) {
                let score = 0;
                for (let i = 0; i < adjacentValues.length; i++) {
                    if (isPair(candidate, adjacentValues[i])) score++;
                }
                if (score < bestScore || (score === bestScore && rng() < 0.5)) {
                    bestScore = score;
                    bestValue = candidate;
                }
            }
            return bestValue;
        }

        /* ============================================================
           NEW: LAYERED PUZZLE GENERATOR (Senior Dev Revision)
           Creates explicit dependency chains by placing blocking pairs.
           ============================================================ */
        function generateLayeredBoard(level) {
            const rng = mulberry32(G.seed++);

            let initialRows = 3;
            if (level >= 4) initialRows = 4;
            if (level >= 6) initialRows = 5;
            if (level >= 8) initialRows = 6;
            if (level >= 10) initialRows = 7;

            const totalCells = initialRows * COLS;
            const grid = new Array(totalCells).fill(0);
            const occupied = new Set();

            G.corruptions = [];
            G.rescueQueue = [];
            G.rowsAddedForCurrentRescue = 0;

            const layers = 1 + Math.floor(level / 2);
            const maxPlacementAttempts = 30;

            // --- PHASE 1: Build layered dependency core ---
            for (let i = 0; i < layers; i++) {
                let attempts = 0;
                let placedLayer = false;
                while (attempts < maxPlacementAttempts && !placedLayer) {
                    const idx1 = Math.floor(rng() * totalCells);
                    const idx2 = Math.floor(rng() * totalCells);
                    const dist = Math.abs(idx1 - idx2);

                    if (!occupied.has(idx1) && !occupied.has(idx2) && idx1 !== idx2 && dist > COLS) {
                        const midPoint = Math.round((idx1 + idx2) / 2);
                        let blockerIdx = -1;

                        for (let offset = 0; offset < COLS; offset++) {
                            const hi = midPoint + offset;
                            const lo = midPoint - offset;
                            if (hi < totalCells && !occupied.has(hi)) {
                                blockerIdx = hi;
                                break;
                            }
                            if (lo >= 0 && !occupied.has(lo)) {
                                blockerIdx = lo;
                                break;
                            }
                        }

                        if (blockerIdx !== -1 && blockerIdx !== idx1 && blockerIdx !== idx2 && !occupied.has(blockerIdx)) {
                            const goalValue = 1 + Math.floor(rng() * 9);
                            const blockerValue = 1 + Math.floor(rng() * 9);

                            grid[idx1] = goalValue;
                            grid[idx2] = goalValue;
                            occupied.add(idx1);
                            occupied.add(idx2);

                            grid[blockerIdx] = blockerValue;
                            occupied.add(blockerIdx);

                            const partnerPos = blockerIdx + 1;
                            if (partnerPos < totalCells && !occupied.has(partnerPos)) {
                                grid[partnerPos] = blockerValue;
                                occupied.add(partnerPos);
                            } else {
                                let fallbackPos = -1;
                                for (let p = 0; p < totalCells; p++) {
                                    if (!occupied.has(p)) {
                                        fallbackPos = p;
                                        break;
                                    }
                                }
                                if (fallbackPos !== -1) {
                                    grid[fallbackPos] = blockerValue;
                                    occupied.add(fallbackPos);
                                }
                            }

                            placedLayer = true;
                        }
                    }
                    attempts++;
                }
            }

            // --- PHASE 2: Fill remaining space naturally ---
            const emptyIndices = [];
            for (let i = 0; i < totalCells; i++) {
                if (!occupied.has(i)) emptyIndices.push(i);
            }
            for (let i = emptyIndices.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [emptyIndices[i], emptyIndices[j]] = [emptyIndices[j], emptyIndices[i]];
            }
            for (let i = 0; i < emptyIndices.length - 1; i += 2) {
                const val = 1 + Math.floor(rng() * 9);
                grid[emptyIndices[i]] = val;
                grid[emptyIndices[i + 1]] = val;
            }

            // --- PHASE 3: Append corruptions below natural grid ---
            const corruptionCount = getCorruptionCount(level);
            if (corruptionCount > 0) {
                const extraRows = Math.ceil(corruptionCount / COLS);
                const appendedStart = grid.length;
                for (let i = 0; i < extraRows * COLS; i++) grid.push(0);

                const slots = chooseSpacedCorruptionSlots(corruptionCount, extraRows, COLS, rng);
                for (let i = 0; i < slots.length; i++) {
                    const slot = slots[i];
                    const targetIdx = appendedStart + slot;
                    const corruptValue = pickNonAdjacentCorruptionValue(grid, targetIdx, rng);
                    grid[targetIdx] = corruptValue;
                    const rescuePartner = rng() < 0.5 ? corruptValue : (10 - corruptValue);
                    G.corruptions.push({
                        value: corruptValue,
                        rescued: false,
                        rescuePartner: rescuePartner,
                        decoyRowsNeeded: Math.floor(level / 4)
                    });
                }
            }

            return grid;
        }

        // Alias for compatibility
        function generateDeterministicBoard(level) {
            return generateLayeredBoard(level);
        }

        function generateFallbackBoard(level) {
            const cfg = ConfigTable[level] || ConfigTable[1];
            const totalCells = cfg.rows * COLS;
            const grid = [];
            while (grid.length + 1 < totalCells) {
                const n = ((grid.length / 2) | 0) % 9 + 1;
                grid.push(n, n);
            }
            while (grid.length < totalCells) grid.push(0);
            return grid;
        }

        /* ============================================================
           9. STRAGGLER DETECTOR â€” finds "loner" numbers whose
           pair-partner has been entirely cleared from the board
           ============================================================ */
        function calculateStragglers() {
            // Count occurrences of each value
            const counts = new Array(10).fill(0); // index 1-9
            for (let i = 0; i < G.grid.length; i++) {
                const v = G.grid[i];
                if (v >= 1 && v <= 9) counts[v]++;
            }

            const loners = [];
            for (let n = 1; n <= 9; n++) {
                if (counts[n] === 0) continue;

                const partner = 10 - n;
                const sameAvail = counts[n]; // how many of this number exist
                const partnerAvail = (partner !== n) ? counts[partner] : 0;

                // A number is a loner if:
                // - It appears an odd number of times (one can't self-pair)
                // - AND it has no sum-to-10 partner on the board
                if (partner === n) {
                    // Self-pairing (n=5): odd count means one is stranded
                    if (sameAvail % 2 === 1) loners.push(n);
                } else {
                    // sameAvail can self-pair in groups of 2; remainder needs partner
                    const remainder = sameAvail % 2;
                    if (remainder > 0 && partnerAvail === 0) loners.push(n);
                }
            }
            return loners;
        }

        function counterValue(value) {
            return value === 5 ? 5 : (10 - value);
        }

        function buildFinalRescueNumbers(remainingValues, rng) {
            const numbers = [];

            // Add exact counters for the final two values.
            for (let i = 0; i < remainingValues.length; i++) {
                numbers.push(counterValue(remainingValues[i]));
            }

            // Add one dummy valid pair (same number or sum-to-10 pair).
            const dummyLeft = 1 + Math.floor(rng() * 9);
            const dummyRight = counterValue(dummyLeft);
            numbers.push(dummyLeft, dummyRight);

            return numbers;
        }

        function buildEndgameRescueNumbers(remainingValues, rng) {
            const numbers = [];

            // Add one exact counter for each remaining number.
            for (let i = 0; i < remainingValues.length; i++) {
                numbers.push(counterValue(remainingValues[i]));
            }

            // Add one dummy valid pair to keep placement robust.
            const dummyLeft = 1 + Math.floor(rng() * 9);
            const dummyRight = counterValue(dummyLeft);
            numbers.push(dummyLeft, dummyRight);

            return numbers;
        }

        function getCorruptionCount(level) {
            if (level < 2) return 0;
            // Smooth but harder progression than the previous linear formula.
            return Math.floor((level - 1) * 2.2);
        }

        /* ============================================================
           10. SMART ADD ROW WITH LAYERED DECOYS
           For corruptions, adds decoy rows first, then rescue in later row
           ============================================================ */
        function addRow() {
            if (G.addRowsLeft <= 0) return;
            G.addRowsLeft--;
            G.totalRowsAdded++;

            const rng = mulberry32(G.seed++);
            const newRow = new Array(COLS).fill(0);
            const remainingValues = [];

            // --- Analyze board for stuck numbers ---
            const stuckNumbers = {};
            for (let i = 0; i < G.grid.length; i++) {
                if (G.grid[i] === 0) continue;

                const value = G.grid[i];
                remainingValues.push(value);
                let hasAdjacentPartner = false;

                // Check all 4 directions
                const col = i % COLS;
                if (col > 0 && isPair(value, G.grid[i - 1])) hasAdjacentPartner = true;
                if (col < COLS - 1 && isPair(value, G.grid[i + 1])) hasAdjacentPartner = true;
                if (i >= COLS && isPair(value, G.grid[i - COLS])) hasAdjacentPartner = true;
                if (i + COLS < G.grid.length && isPair(value, G.grid[i + COLS])) hasAdjacentPartner = true;

                if (!hasAdjacentPartner) {
                    stuckNumbers[value] = (stuckNumbers[value] || 0) + 1;
                }
            }

            // --- Handle Corruption Rescue with Decoy Layers ---
            const unrescuedCorruptions = G.corruptions.filter(c => !c.rescued);
            let isRescueRow = false;
            let rescueNumber = null;
            const isFinalRescueScenario = remainingValues.length === 2;
            const isThreeEndgameScenario = unrescuedCorruptions.length === 0 && remainingValues.length === 3;

            if (!isFinalRescueScenario && unrescuedCorruptions.length > 0) {
                const corruption = unrescuedCorruptions[0];

                // Track decoy rows added for this corruption
                if (!corruption.decoyRowsAdded) corruption.decoyRowsAdded = 0;

                const decoyRowsNeeded = corruption.decoyRowsNeeded || 0;

                if (corruption.decoyRowsAdded < decoyRowsNeeded) {
                    // Add DECOY row (pairs that block the rescue)
                    corruption.decoyRowsAdded++;
                    setMsg(`Decoy layer ${corruption.decoyRowsAdded}/${decoyRowsNeeded} added. Clear pairs to progress!`);
                } else {
                    // Add RESCUE row
                    isRescueRow = true;
                    rescueNumber = corruption.rescuePartner;
                    corruption.rescued = true;
                    setMsg(`Rescue number ${rescueNumber} found! Match with corruption ${corruption.value}!`);
                }
            }

            // --- Build Row with Natural Distribution ---
            const numbers = [];

            if (isFinalRescueScenario) {
                numbers.push(...buildFinalRescueNumbers(remainingValues, rng));
                setMsg(`Final rescue row: ${counterValue(remainingValues[0])}, ${counterValue(remainingValues[1])} + dummy pair.`);
            } else if (isThreeEndgameScenario) {
                numbers.push(...buildEndgameRescueNumbers(remainingValues, rng));
                setMsg(`Endgame rescue row added: counters for all 3 remaining numbers + dummy pair.`);
            } else if (isRescueRow && rescueNumber !== null) {
                // RESCUE ROW: Add rescue number PAIR + blocking pairs
                numbers.push(rescueNumber, rescueNumber); // Add as pair to ensure even count

                // Add 1-2 blocking pairs around it (layered difficulty)
                const blockingPairs = 1 + Math.floor(rng() * 2);
                for (let i = 0; i < blockingPairs; i++) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            } else if (unrescuedCorruptions.length > 0) {
                // DECOY ROW: Add only pairs (no rescue yet)
                const decoyPairs = 3 + Math.floor(rng() * 2); // 3-4 pairs
                for (let i = 0; i < decoyPairs; i++) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            } else {
                // HELPFUL ROW: Add partners for stuck numbers
                const stuckList = Object.keys(stuckNumbers).map(k => parseInt(k, 10));
                // In endgame, cover all remaining stuck values so no value is ignored (e.g. 9 -> 1).
                const helpCount = remainingValues.length <= 6
                    ? stuckList.length
                    : Math.min(3, stuckList.length);

                for (let i = 0; i < helpCount; i++) {
                    const stuckValue = stuckList[i];
                    const partner = stuckValue === 5 ? 5 : (10 - stuckValue);
                    numbers.push(partner, partner); // Add as pair
                }

                // Fill rest with random pairs if space
                while (numbers.length < 6 && rng() < 0.6) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            }

            // --- Humanized Placement (Natural Clustering) ---
            // Shuffle numbers
            for (let i = numbers.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
            }

            // Place with natural spacing (70-90% fill)
            let numIdx = 0;
            for (let col = 0; col < COLS && numIdx < numbers.length; col++) {
                const fillChance = (isFinalRescueScenario || isThreeEndgameScenario) ? 1.0 : (0.7 + rng() * 0.2);
                if (rng() < fillChance || col === COLS - 1) {
                    newRow[col] = numbers[numIdx++];
                }
            }

            // Append row to grid
            while (G.grid.length > 0 && G.grid[G.grid.length - 1] === 0) G.grid.pop();
            for (let i = 0; i < COLS; i++) G.grid.push(newRow[i]);
            G.rows = Math.ceil(G.grid.length / COLS);

            // Check for row collapse
            collapseEmptyRows();

            render();
            updateHUD();

            const moveCount = findAllMoves(G.grid).length;
            if (!isRescueRow && unrescuedCorruptions.length === 0) {
                setMsg(`Smart row added! ${moveCount} moves available.`);
            }
        }
        /* ============================================================
           ROW COLLAPSE â€” Remove completely empty rows and shift up
           ============================================================ */
        function collapseEmptyRows() {
            const rowCount = Math.ceil(G.grid.length / COLS);
            let collapsedAny = false;

            for (let row = rowCount - 1; row >= 0; row--) {
                const startIdx = row * COLS;
                const endIdx = startIdx + COLS;

                // Check if row is completely empty
                let isEmpty = true;
                for (let i = startIdx; i < endIdx && i < G.grid.length; i++) {
                    if (G.grid[i] !== 0) {
                        isEmpty = false;
                        break;
                    }
                }

                if (isEmpty) {
                    // Remove this row
                    G.grid.splice(startIdx, COLS);
                    G.rows = Math.ceil(G.grid.length / COLS);
                    collapsedAny = true;
                }
            }

            if (collapsedAny) {
                setMsg('Empty rows collapsed! Board compacted.');
            }
        }

        /* ============================================================
           11. SHUFFLE MECHANIC (Level 3+) â€” 50/50 Risk/Reward
           Progressive limit: L3=3, L4=4, L5=5, etc.
           ============================================================ */
        function cloneCorruptions(corruptions) {
            return corruptions.map(c => ({
                value: c.value,
                rescued: !!c.rescued,
                rescuePartner: c.rescuePartner,
                decoyRowsNeeded: c.decoyRowsNeeded || 0,
                decoyRowsAdded: c.decoyRowsAdded || 0
            }));
        }

        function solverCollapseEmptyRows(grid) {
            const out = grid.slice();
            const rowCount = Math.ceil(out.length / COLS);
            for (let row = rowCount - 1; row >= 0; row--) {
                const startIdx = row * COLS;
                const endIdx = startIdx + COLS;
                let isEmpty = true;
                for (let i = startIdx; i < endIdx && i < out.length; i++) {
                    if (out[i] !== 0) {
                        isEmpty = false;
                        break;
                    }
                }
                if (isEmpty) out.splice(startIdx, COLS);
            }
            return out;
        }

        function solverTrimTrailingEmptyRows(grid) {
            const out = grid.slice();
            while (out.length > COLS && isRowEmpty(out, out.length - COLS)) {
                out.length -= COLS;
            }
            return out;
        }

        function solverHasUnrescuedCorruptions(state) {
            const present = new Set();
            for (let i = 0; i < state.grid.length; i++) {
                const v = state.grid[i];
                if (v !== 0) present.add(v);
            }
            for (let i = 0; i < state.corruptions.length; i++) {
                const c = state.corruptions[i];
                if (!c.rescued && present.has(c.value)) return true;
            }
            return false;
        }

        function solverIsWin(state) {
            let remaining = 0;
            for (let i = 0; i < state.grid.length; i++) {
                if (state.grid[i] !== 0) remaining++;
            }
            if (solverHasUnrescuedCorruptions(state)) return false;
            return remaining <= 1;
        }

        function solverApplyMatch(state, i, j) {
            const next = {
                grid: state.grid.slice(),
                addRowsLeft: state.addRowsLeft,
                shufflesLeft: state.shufflesLeft,
                seed: state.seed,
                corruptions: cloneCorruptions(state.corruptions)
            };

            const valI = next.grid[i];
            const valJ = next.grid[j];
            markCorruptionsRescuedByMatch(next.corruptions, valI, valJ);

            next.grid[i] = 0;
            next.grid[j] = 0;
            next.grid = solverTrimTrailingEmptyRows(next.grid);
            next.grid = solverCollapseEmptyRows(next.grid);
            return next;
        }

        function solverApplyAddRow(state) {
            if (state.addRowsLeft <= 0) return null;
            const next = {
                grid: state.grid.slice(),
                addRowsLeft: state.addRowsLeft - 1,
                shufflesLeft: state.shufflesLeft,
                seed: state.seed + 1,
                corruptions: cloneCorruptions(state.corruptions)
            };

            const rng = mulberry32(state.seed);
            const newRow = new Array(COLS).fill(0);
            const remainingValues = [];

            const stuckNumbers = {};
            for (let i = 0; i < next.grid.length; i++) {
                if (next.grid[i] === 0) continue;
                const value = next.grid[i];
                remainingValues.push(value);
                let hasAdjacentPartner = false;
                const col = i % COLS;
                if (col > 0 && isPair(value, next.grid[i - 1])) hasAdjacentPartner = true;
                if (col < COLS - 1 && isPair(value, next.grid[i + 1])) hasAdjacentPartner = true;
                if (i >= COLS && isPair(value, next.grid[i - COLS])) hasAdjacentPartner = true;
                if (i + COLS < next.grid.length && isPair(value, next.grid[i + COLS])) hasAdjacentPartner = true;
                if (!hasAdjacentPartner) {
                    stuckNumbers[value] = (stuckNumbers[value] || 0) + 1;
                }
            }

            const unrescuedCorruptions = next.corruptions.filter(c => !c.rescued);
            let isRescueRow = false;
            let rescueNumber = null;
            const isFinalRescueScenario = remainingValues.length === 2;
            const isThreeEndgameScenario = unrescuedCorruptions.length === 0 && remainingValues.length === 3;
            if (!isFinalRescueScenario && unrescuedCorruptions.length > 0) {
                const corruption = unrescuedCorruptions[0];
                if (!corruption.decoyRowsAdded) corruption.decoyRowsAdded = 0;
                const decoyRowsNeeded = corruption.decoyRowsNeeded || 0;
                if (corruption.decoyRowsAdded < decoyRowsNeeded) {
                    corruption.decoyRowsAdded++;
                } else {
                    isRescueRow = true;
                    rescueNumber = corruption.rescuePartner;
                    corruption.rescued = true;
                }
            }

            const numbers = [];
            if (isFinalRescueScenario) {
                numbers.push(...buildFinalRescueNumbers(remainingValues, rng));
            } else if (isThreeEndgameScenario) {
                numbers.push(...buildEndgameRescueNumbers(remainingValues, rng));
            } else if (isRescueRow && rescueNumber !== null) {
                numbers.push(rescueNumber, rescueNumber);
                const blockingPairs = 1 + Math.floor(rng() * 2);
                for (let i = 0; i < blockingPairs; i++) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            } else if (unrescuedCorruptions.length > 0) {
                const decoyPairs = 3 + Math.floor(rng() * 2);
                for (let i = 0; i < decoyPairs; i++) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            } else {
                const stuckList = Object.keys(stuckNumbers).map(k => parseInt(k, 10));
                const helpCount = remainingValues.length <= 6
                    ? stuckList.length
                    : Math.min(3, stuckList.length);
                for (let i = 0; i < helpCount; i++) {
                    const stuckValue = stuckList[i];
                    const partner = stuckValue === 5 ? 5 : (10 - stuckValue);
                    numbers.push(partner, partner);
                }
                while (numbers.length < 6 && rng() < 0.6) {
                    const value = 1 + Math.floor(rng() * 9);
                    numbers.push(value, value);
                }
            }

            for (let i = numbers.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
            }

            let numIdx = 0;
            for (let col = 0; col < COLS && numIdx < numbers.length; col++) {
                const fillChance = (isFinalRescueScenario || isThreeEndgameScenario) ? 1.0 : (0.7 + rng() * 0.2);
                if (rng() < fillChance || col === COLS - 1) {
                    newRow[col] = numbers[numIdx++];
                }
            }

            while (next.grid.length > 0 && next.grid[next.grid.length - 1] === 0) next.grid.pop();
            for (let i = 0; i < COLS; i++) next.grid.push(newRow[i]);
            next.grid = solverCollapseEmptyRows(next.grid);
            return next;
        }

        function solverApplyShuffle(state) {
            if (state.shufflesLeft <= 0) return null;
            const next = {
                grid: state.grid.slice(),
                addRowsLeft: state.addRowsLeft,
                shufflesLeft: state.shufflesLeft - 1,
                seed: state.seed + 1,
                corruptions: cloneCorruptions(state.corruptions)
            };

            const rng = mulberry32(state.seed);
            const isGoodShuffle = rng() < 0.5;
            const cells = [];
            for (let i = 0; i < next.grid.length; i++) {
                if (next.grid[i] !== 0) cells.push({ index: i, value: next.grid[i] });
            }
            const positions = cells.map(c => c.index);
            const values = cells.map(c => c.value);
            if (positions.length === 0) return next;

            if (isGoodShuffle) {
                const newValues = [];
                const used = new Set();
                for (let i = 0; i < values.length; i++) {
                    if (used.has(i)) continue;
                    let foundPartner = false;
                    for (let j = i + 1; j < values.length; j++) {
                        if (used.has(j)) continue;
                        if (isPair(values[i], values[j])) {
                            newValues.push(values[i], values[j]);
                            used.add(i);
                            used.add(j);
                            foundPartner = true;
                            break;
                        }
                    }
                    if (!foundPartner) {
                        newValues.push(values[i]);
                        used.add(i);
                    }
                }

                const sortedPositions = positions.slice().sort((a, b) => a - b);
                const adjacentGroups = [];
                let currentGroup = [sortedPositions[0]];
                for (let i = 1; i < sortedPositions.length; i++) {
                    if (sortedPositions[i] - sortedPositions[i - 1] === 1) currentGroup.push(sortedPositions[i]);
                    else {
                        if (currentGroup.length > 0) adjacentGroups.push(currentGroup);
                        currentGroup = [sortedPositions[i]];
                    }
                }
                if (currentGroup.length > 0) adjacentGroups.push(currentGroup);

                const finalPositions = [];
                let valueIdx = 0;
                for (let g = 0; g < adjacentGroups.length; g++) {
                    const group = adjacentGroups[g];
                    for (let p = 0; p < group.length; p++) {
                        if (valueIdx < newValues.length) {
                            finalPositions.push({ pos: group[p], val: newValues[valueIdx++] });
                        }
                    }
                }

                for (let i = 0; i < cells.length; i++) next.grid[cells[i].index] = 0;
                for (let i = 0; i < finalPositions.length; i++) {
                    next.grid[finalPositions[i].pos] = finalPositions[i].val;
                }
            } else {
                for (let i = values.length - 1; i > 0; i--) {
                    const maxDist = Math.floor(i * 0.7);
                    const j = Math.max(0, i - maxDist) + Math.floor(rng() * (maxDist + 1));
                    [values[i], values[j]] = [values[j], values[i]];
                }
                for (let i = 0; i < cells.length; i++) next.grid[cells[i].index] = 0;
                for (let i = 0; i < positions.length; i++) next.grid[positions[i]] = values[i];
            }

            return next;
        }

        function solverStateKey(state) {
            const corruptionKey = state.corruptions
                .map(c => [c.value, c.rescued ? 1 : 0, c.rescuePartner, c.decoyRowsNeeded || 0, c.decoyRowsAdded || 0].join(','))
                .join(';');
            return state.addRowsLeft + '|' + state.shufflesLeft + '|' + state.seed + '|' +
                state.grid.join(',') + '|' + corruptionKey;
        }

        function isBoardSolvable(initialState) {
            const MAX_NODES = 30000;
            const MAX_DEPTH = 70;
            const MAX_MOVES_PER_STATE = 18;
            let nodes = 0;
            const memo = new Map();

            function dfs(state, depth) {
                if (solverIsWin(state)) return true;
                if (depth >= MAX_DEPTH) return false;
                nodes++;
                if (nodes > MAX_NODES) return false;

                const key = solverStateKey(state);
                if (memo.has(key)) return memo.get(key);

                const moves = findAllMoves(state.grid);
                moves.sort((a, b) => Math.abs(a[0] - a[1]) - Math.abs(b[0] - b[1]));
                const moveLimit = Math.min(MAX_MOVES_PER_STATE, moves.length);

                for (let i = 0; i < moveLimit; i++) {
                    const m = moves[i];
                    if (dfs(solverApplyMatch(state, m[0], m[1]), depth + 1)) {
                        memo.set(key, true);
                        return true;
                    }
                }

                if (state.addRowsLeft > 0) {
                    const addState = solverApplyAddRow(state);
                    if (addState && dfs(addState, depth + 1)) {
                        memo.set(key, true);
                        return true;
                    }
                }

                if (state.shufflesLeft > 0) {
                    const shuffleState = solverApplyShuffle(state);
                    if (shuffleState && dfs(shuffleState, depth + 1)) {
                        memo.set(key, true);
                        return true;
                    }
                }

                memo.set(key, false);
                return false;
            }

            return dfs(initialState, 0);
        }

        function shuffleBoard() {
            if (G.shufflesLeft <= 0 || G.animating) return;
            G.shufflesLeft--;
            G.shufflesUsed++;
            G.animating = true;

            const rng = mulberry32(G.seed++);
            const isGoodShuffle = rng() < 0.5; // 50% chance

            // Get all non-zero cell indices and values
            const cells = [];
            for (let i = 0; i < G.grid.length; i++) {
                if (G.grid[i] !== 0) {
                    cells.push({ index: i, value: G.grid[i] });
                }
            }

            // Store original positions and values
            const positions = cells.map(c => c.index);
            const values = cells.map(c => c.value);

            if (isGoodShuffle) {
                // GOOD SHUFFLE: Group pairs closer together
                setMsg('ðŸ€ Lucky! Pairs moving closer together...');

                // Build a new arrangement that groups pairs
                const newValues = [];
                const used = new Set();

                // Find pairs and group them together in the values array
                for (let i = 0; i < values.length; i++) {
                    if (used.has(i)) continue;

                    // Find a partner for this value
                    let foundPartner = false;
                    for (let j = i + 1; j < values.length; j++) {
                        if (used.has(j)) continue;

                        if (isPair(values[i], values[j])) {
                            // Found a pair! Add them consecutively
                            newValues.push(values[i]);
                            newValues.push(values[j]);
                            used.add(i);
                            used.add(j);
                            foundPartner = true;
                            break;
                        }
                    }

                    // If no partner found, add the value anyway
                    if (!foundPartner) {
                        newValues.push(values[i]);
                        used.add(i);
                    }
                }

                // Now shuffle positions to try to place consecutive pairs adjacently
                // Sort positions to find adjacent slots
                const sortedPositions = [...positions].sort((a, b) => a - b);
                const adjacentGroups = [];
                let currentGroup = [sortedPositions[0]];

                for (let i = 1; i < sortedPositions.length; i++) {
                    if (sortedPositions[i] - sortedPositions[i - 1] === 1) {
                        currentGroup.push(sortedPositions[i]);
                    } else {
                        if (currentGroup.length > 0) adjacentGroups.push(currentGroup);
                        currentGroup = [sortedPositions[i]];
                    }
                }
                if (currentGroup.length > 0) adjacentGroups.push(currentGroup);

                // Place pairs in adjacent groups when possible
                const finalPositions = [];
                let valueIdx = 0;
                for (const group of adjacentGroups) {
                    for (const pos of group) {
                        if (valueIdx < newValues.length) {
                            finalPositions.push({ pos: pos, val: newValues[valueIdx++] });
                        }
                    }
                }

                // Clear all positions and place shuffled values
                for (const cell of cells) {
                    G.grid[cell.index] = 0;
                }
                for (const item of finalPositions) {
                    G.grid[item.pos] = item.val;
                }
            } else {
                // BAD SHUFFLE: Scatter pairs far apart
                setMsg('ðŸ’€ Unlucky! Pairs scattered apart...');

                // Fisher-Yates shuffle with bias toward distance
                for (let i = values.length - 1; i > 0; i--) {
                    // Bias toward swapping with distant elements
                    const maxDist = Math.floor(i * 0.7);
                    const j = Math.max(0, i - maxDist) + Math.floor(rng() * (maxDist + 1));
                    [values[i], values[j]] = [values[j], values[i]];
                }

                // Clear old positions and place shuffled values
                for (const cell of cells) {
                    G.grid[cell.index] = 0;
                }
                for (let i = 0; i < positions.length; i++) {
                    G.grid[positions[i]] = values[i];
                }
            }

            // Animate shuffle effect
            render();
            updateHUD();

            setTimeout(() => {
                G.animating = false;
                const moveCount = findAllMoves(G.grid).length;
                setMsg((isGoodShuffle ? 'âœ¨ Good shuffle! ' : 'âš ï¸ Bad shuffle! ') +
                    moveCount + ' moves available. Shuffles left: ' + G.shufflesLeft);
            }, 500);
        }

        /* ============================================================
           12. GAME ACTIONS â€” select, match, hint
           ============================================================ */
        function selectCell(index) {
            if (G.animating) return;
            if (index < 0 || index >= G.grid.length) return;
            if (G.grid[index] === 0) return;

            // First selection
            if (G.selected === -1) {
                G.selected = index;
                render();
                return;
            }

            // Deselect
            if (G.selected === index) {
                G.selected = -1;
                render();
                return;
            }

            // Attempt match
            if (canMatch(G.grid, G.selected, index)) {
                const i = G.selected, j = index;
                const valI = G.grid[i];
                const valJ = G.grid[j];
                G.animating = true;
                G.selected = -1;

                // Mark matched corruption instances as rescued (count-aware).
                const beforeUnrescued = G.corruptions.filter(c => !c.rescued).length;
                markCorruptionsRescuedByMatch(G.corruptions, valI, valJ);
                const afterUnrescued = G.corruptions.filter(c => !c.rescued).length;
                if (afterUnrescued < beforeUnrescued) {
                    setMsg('Corruption rescued! ' + afterUnrescued + ' remaining.');
                }

                // Animate
                const cells = document.querySelectorAll('.cell');
                if (cells[i]) cells[i].classList.add('matched');
                if (cells[j]) cells[j].classList.add('matched');

                setTimeout(() => {
                    G.grid[i] = 0;
                    G.grid[j] = 0;
                    G.moves++;
                    G.addWithoutMatch = 0;

                    // Trim trailing empty rows
                    while (G.grid.length > COLS && isRowEmpty(G.grid, G.grid.length - COLS)) {
                        G.grid.length -= COLS;
                    }
                    G.rows = Math.ceil(G.grid.length / COLS);

                    // Collapse any empty rows and push lower rows up
                    collapseEmptyRows();

                    G.animating = false;
                    render();
                    updateHUD();
                    checkWin();
                }, 280);
            } else {
                // Invalid match â€” shake second cell
                const cells = document.querySelectorAll('.cell');
                if (cells[index]) cells[index].classList.add('invalid');
                setMsg('Not a valid match');
                G.selected = -1;
                setTimeout(() => {
                    render();
                    setMsg('');
                }, 400);
            }
        }

        function isRowEmpty(grid, startIdx) {
            for (let c = 0; c < COLS && startIdx + c < grid.length; c++) {
                if (grid[startIdx + c] !== 0) return false;
            }
            return true;
        }

        function checkWin() {
            let remaining = 0;
            const remainingValues = [];
            for (let i = 0; i < G.grid.length; i++) {
                if (G.grid[i] !== 0) {
                    remaining++;
                    remainingValues.push(G.grid[i]);
                }
            }

            // Check if any remaining numbers are unrescued corruptions
            const hasUnrescuedCorruptions = G.corruptions.some(c => {
                if (!c.rescued) {
                    // Check if this corruption value still exists on the board
                    return remainingValues.includes(c.value);
                }
                return false;
            });

            // Don't win if unrescued corruptions remain - they need rescue partners
            if (hasUnrescuedCorruptions) {
                return;
            }

            // Win if 0 or 1 numbers remain (1 number can't be paired)
            // AND all corruptions have been rescued
            if (remaining <= 1) {
                const addRowsUsed = (G.level >= 5 ? (10 + G.level * 2) : (6 + G.level)) - G.addRowsLeft;
                const shuffleText = G.level >= 2 && G.shufflesUsed > 0 ? ', ' + G.shufflesUsed + ' shuffles' : '';
                const perfection = remaining === 0 ? ' ðŸŒŸ Perfect!' : '';
                const corruptionText = G.corruptions.length > 0 ? G.corruptions.length + ' corruptions rescued, ' : '';
                document.getElementById('lc-text').textContent =
                    'ðŸŽ‰ Level ' + G.level + ' cleared!' + perfection + ' ' + G.moves + ' moves, ' +
                    corruptionText + addRowsUsed + ' rows added' + shuffleText + '.';
                document.getElementById('level-complete').classList.add('show');
            }
        }

        function showHint() {
            if (G.animating) return;
            G.selected = -1;

            const moves = findAllMoves(G.grid);
            if (moves.length === 0) {
                setMsg('No moves available \u2014 use + Add Row');
                return;
            }

            render(); // clear any previous selection highlight

            const [a, b] = moves[0];
            const cells = document.querySelectorAll('.cell');
            if (cells[a]) cells[a].classList.add('hint-glow');
            if (cells[b]) cells[b].classList.add('hint-glow');

            setMsg('Hint: row ' + (((a / COLS) | 0) + 1) + ' col ' + (a % COLS + 1) +
                '  &  row ' + (((b / COLS) | 0) + 1) + ' col ' + (b % COLS + 1));
        }

        /* ============================================================
           13. RENDERING
           ============================================================ */
        function getMinDisplayRows(level) {
            return level >= 5 ? 10 : 0;
        }

        function isCorruption(value, corruptionCounts) {
            if (value === 0) return false;
            if ((corruptionCounts[value] || 0) > 0) {
                corruptionCounts[value]--;
                return true;
            }
            return false;
        }

        function render() {
            const board = document.getElementById('board');
            // Pad grid to full rows
            while (G.grid.length % COLS !== 0) G.grid.push(0);
            G.rows = G.grid.length / COLS;
            const displayRows = Math.max(G.rows, getMinDisplayRows(G.level));
            const displayCells = displayRows * COLS;
            const corruptionCounts = buildUnrescuedCorruptionCountMap(G.corruptions);

            const frags = [];
            for (let i = 0; i < displayCells; i++) {
                const v = i < G.grid.length ? G.grid[i] : 0;
                const empty = v === 0;
                const sel = i === G.selected;

                let cls = 'cell';
                if (empty) cls += ' empty';
                else {
                    cls += ' num';
                    if (sel) cls += ' selected';
                }
                frags.push('<div class="' + cls + '" data-i="' + i + '">' +
                    (empty ? '' : v) + '</div>');
            }
            board.innerHTML = frags.join('');

            // Attach click handlers to number cells
            const numCells = board.querySelectorAll('.cell.num');
            for (let c = 0; c < numCells.length; c++) {
                numCells[c].addEventListener('click', handleCellClick);
            }
        }

        function handleCellClick(e) {
            selectCell(parseInt(e.currentTarget.dataset.i, 10));
        }

        function updateHUD() {
            let remaining = 0;
            for (let i = 0; i < G.grid.length; i++) {
                if (G.grid[i] !== 0) remaining++;
            }
            const unrescuedCorruptions = G.corruptions.filter(c => !c.rescued).length;
            document.getElementById('h-level').textContent = G.level;
            document.getElementById('h-moves').textContent = G.moves;
            document.getElementById('h-adds').textContent = G.addRowsLeft;
            document.getElementById('h-corrupt').textContent = unrescuedCorruptions;
            document.getElementById('h-remain').textContent = remaining;
            document.getElementById('add-count').textContent = G.addRowsLeft;
            document.getElementById('btn-add').disabled = G.addRowsLeft <= 0;

            // Update shuffle button
            if (G.level >= 2) {
                const shuffleBtn = document.getElementById('btn-shuffle');
                shuffleBtn.disabled = G.shufflesLeft <= 0;
                shuffleBtn.textContent = 'Shuffle (' + G.shufflesLeft + ')';
            }
        }

        function setMsg(t) { document.getElementById('msg').textContent = t; }

        /* ============================================================
           14. LEVEL MANAGEMENT
           ============================================================ */
        function startLevel(level) {
            G.level = level;
            G.moves = 0;
            G.addRowsLeft = level >= 5 ? (10 + level * 2) : (6 + level);
            G.shufflesLeft = level >= 2 ? 10 : 0;
            G.shufflesUsed = 0;
            G.selected = -1;
            G.addWithoutMatch = 0;
            G.animating = false;

            G.corruptions = [];
            G.rescueQueue = [];
            G.rowsAddedForCurrentRescue = 0;
            document.getElementById('level-select').value = String(level);

            const shuffleBtn = document.getElementById('btn-shuffle');
            if (level >= 2) shuffleBtn.style.display = 'inline-block';
            else shuffleBtn.style.display = 'none';

            let initialRows = 3;
            if (level >= 4 && level <= 5) initialRows = 4;
            else if (level >= 6 && level <= 7) initialRows = 5;
            else if (level >= 8 && level <= 9) initialRows = 6;
            else if (level >= 10) initialRows = 7;

            const corruptionCount = getCorruptionCount(level);
            setMsg('Building layered puzzle (' + initialRows + ' rows, ' + corruptionCount + ' corruptions)...');

            setTimeout(function () {
                const levelSeeds = SOLVABLE_SEEDS[Math.min(level, 10)] || [0];
                const MAX_SOLVER_ATTEMPTS = 80;
                let found = false;
                let fallbackGrid = [];
                let fallbackCorruptions = [];
                let fallbackSeed = 1;

                for (let attempt = 0; attempt < MAX_SOLVER_ATTEMPTS; attempt++) {
                    const seedBase = levelSeeds[attempt % levelSeeds.length];
                    const candidateSeed = level * 31337 + seedBase + attempt * 7919;

                    G.seed = candidateSeed;
                    G.corruptions = [];
                    G.rescueQueue = [];
                    G.rowsAddedForCurrentRescue = 0;

                    const candidateGrid = generateLayeredBoard(level);
                    const candidateCorruptions = cloneCorruptions(G.corruptions);
                    const state = {
                        grid: candidateGrid.slice(),
                        addRowsLeft: G.addRowsLeft,
                        shufflesLeft: G.shufflesLeft,
                        seed: G.seed,
                        corruptions: cloneCorruptions(candidateCorruptions)
                    };

                    fallbackGrid = candidateGrid.slice();
                    fallbackCorruptions = candidateCorruptions;
                    fallbackSeed = G.seed;

                    if (isBoardSolvable(state)) {
                        G.grid = candidateGrid.slice();
                        G.corruptions = candidateCorruptions;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    G.grid = fallbackGrid;
                    G.corruptions = fallbackCorruptions;
                    G.seed = fallbackSeed;
                }

                G.rows = Math.ceil(G.grid.length / COLS);
                G.totalRowsAdded = 0;
                render();
                updateHUD();

                const moveCount = findAllMoves(G.grid).length;
                const unrescued = G.corruptions.filter(c => !c.rescued).length;
                const shuffleText = level >= 2 ? ' | 10 shuffles' : '';
                const layerHint = level >= 4 ? ' | Rescue needs ' + Math.floor(level / 4) + ' decoy rows' : '';
                const solverText = found ? ' | Solvable seed locked' : ' | Solver fallback';
                setMsg(moveCount + ' moves | ' + unrescued + ' corruptions' + shuffleText + layerHint + solverText + ' | Plan your moves!');
            }, 16);
        }

        function nextLevel() {
            document.getElementById('level-complete').classList.remove('show');
            startLevel(G.level < 20 ? G.level + 1 : 1);
        }

        /* ============================================================
           15. INIT
           ============================================================ */
        document.getElementById('btn-add').addEventListener('click', addRow);
        document.getElementById('btn-shuffle').addEventListener('click', shuffleBoard);
        document.getElementById('btn-hint').addEventListener('click', showHint);
        document.getElementById('btn-restart').addEventListener('click', function () { startLevel(G.level); });
        document.getElementById('btn-next').addEventListener('click', nextLevel);
        document.getElementById('btn-jump').addEventListener('click', function () {
            const v = parseInt(document.getElementById('level-select').value, 10);
            if (v >= 1 && v <= 20) startLevel(v);
        });
        document.getElementById('level-select').addEventListener('change', function () {
            const v = parseInt(this.value, 10);
            if (v >= 1 && v <= 20) startLevel(v);
        });

        startLevel(1);
    </script>
</body>

</html>
